1,1626c1
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
< #define STDC_HEADERS 1
< #define HAVE_STRING_H 1
< #define HAVE_SYS_PARAM_H 1
< #define HAVE_UNISTD_H 1
< #define HAVE_ALLOCA_H 1
< #define HAVE_GETPAGESIZE 1
< #define HAVE_MEMCHR 1
< #define HAVE_STRERROR 1
< #define HAVE_VALLOC 1
< #define HAVE_WORKING_MMAP 1
< #ifdef STDC_HEADERS
< #if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
< #ifdef HAVE_UNISTD_H
< #undef MAX
< #define MAX(A,B) ((A) > (B) ? (A) : (B))
< /* Provide missing ANSI features if necessary. */
< #ifndef HAVE_STRERROR
< #ifndef HAVE_MEMCHR
<     fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
<     fprintf(stderr, "%s: %s\n", prog, mesg);
< #if !defined(HAVE_VALLOC)
< static char *buffer;		/* Base of buffer. */
< static size_t bufsalloc;	/* Allocated size of buffer save region. */
< static char *bufbeg;		/* Beginning of user-visible stuff. */
< #if defined(HAVE_WORKING_MMAP)
< #ifndef BUFSALLOC
<       bufsalloc = MAX(8192, getpagesize());
<       bufsalloc = BUFSALLOC;
< #if defined(HAVE_WORKING_MMAP)
< #if defined(HAVE_WORKING_MMAP)
< #if defined(HAVE_WORKING_MMAP)
<       maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
< 		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
< 	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
<       /* You might thing this (or MADV_WILLNEED) would help,
<       madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
<     if (*beg == '\n')
<       if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
< /* Print the lines between BEG and LIM.  Deal with context crap.
<    If NLINESP is non-null, store a count of lines between BEG and LIM. */
< 	  while (p > bp && p[-1] != '\n');
< 	  nl = memchr(p, '\n', beg - p);
< 	  if ((nl = memchr(p, '\n', lim - p)) != 0)
<       /* Avoid matching the empty line at the end of the buffer. */
<       if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
<       for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
< 	  while (beg > bufbeg && beg[-1] != '\n');
< #define USAGE \
<   "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
<   fprintf(stderr, USAGE, prog);
<   while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
<       case 'A':
<       case 'B':
< 	fprintf(stderr, "%s\n", version);
< 	  keys[keycc++] = '\n';
< 	  keys[keycc++] = '\n';
< 	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
< 		printf("%d\n", count);
< 		  printf("%s\n", filename);
< 	      printf("%s\n", filename);
< 	printf("%d\n", count);
< 	    printf("(standard input)\n");
< 	printf("(standard input)\n");
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
< /* NOTE!!!  AIX requires this to be the first thing in the file.
<    Do not put ANYTHING before it!  */
< #if !defined (__GNUC__) && defined (_AIX)
< #ifdef HAVE_CONFIG_H
< #if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
< #ifndef _AIX
< /* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
< #if defined (_LIBC) || !defined (__GNU_LIBRARY__)
<    to get __GNU_LIBRARY__ defined.  */
< #ifdef	__GNU_LIBRARY__
< /* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
<    long-named option.  Because this is not POSIX.2 compliant, it is
< /* #define GETOPT_COMPAT */
<    As `getopt' works, it permutes the elements of ARGV so that,
<    Also, when `ordering' is RETURN_IN_ORDER,
<    each non-option ARGV-element is returned here.  */
< /* Index in ARGV of the next element to be scanned.
<    how much of ARGV has been scanned so far.  */
<    by advancing to the next ARGV-element.  */
< /* Describe how to deal with options that follow non-option ARGV-elements.
<    PERMUTE is the default.  We permute the contents of ARGV as we scan,
<    to expect options and other ARGV-elements in any order and that care about
<    the ordering of the two.  We describe each non-option ARGV-element
<    `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
< #ifdef	__GNU_LIBRARY__
< /* Avoid depending on library functions or files
< /* Describe the part of ARGV that contains non-options that have
<    been skipped.  `first_nonopt' is the index in ARGV of the first of them;
< /* Exchange two adjacent subsequences of ARGV.
<    the new indices of the non-options in ARGV after they are moved.  */
<   /* Interchange the two blocks of data in ARGV.  */
< /* Scan elements of ARGV (whose length is ARGC) for option characters
<    If an element of ARGV starts with '-', and is not exactly "-" or "--",
<    resume the scan with the following option character or ARGV-element.
<    Then `optind' is the index in ARGV of the first ARGV-element
<    that is not an option.  (The ARGV-elements have been permuted
<    so the following text in the same ARGV-element, or the text of the following
<    ARGV-element, is returned in `optarg'.  Two colons mean an option that
<    wants an optional arg; if there is text in the current ARGV-element,
<    handling the non-option ARGV-elements.
<    argument, it follows the option name in the same ARGV-element, separated
<    from the option name by a `=', or else the in next ARGV-element.
<    The elements of ARGV aren't really const, because we permute them.
<    But we pretend they're const in the prototype to be compatible
<      Start processing options with ARGV-element 1 (since ARGV-element 0
<      non-option ARGV-elements is empty.  */
<   if (nextchar == NULL || *nextchar == '\0')
< 		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
< #ifdef GETOPT_COMPAT
< 		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
< #endif				/* GETOPT_COMPAT */
<       /* Special ARGV-element `--' means premature end of options.
<       /* If we have done all the ARGV-elements, stop the scan
<       if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
< #ifdef GETOPT_COMPAT
< 	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
< #endif				/* GETOPT_COMPAT */
<       /* We have found another option-ARGV-element.
< #ifdef GETOPT_COMPAT
< #endif				/* GETOPT_COMPAT */
< 	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
< 				 "%s: option `--%s' doesn't allow an argument\n",
< 			     "%s: option `%c%s' doesn't allow an argument\n",
< 		    fprintf (stderr, "%s: option `%s' requires an argument\n",
< #ifdef GETOPT_COMPAT
< #endif				/* GETOPT_COMPAT */
< 		fprintf (stderr, "%s: unrecognized option `--%s'\n",
< 		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
<     if (*nextchar == '\0')
< 	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
< 	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
< 	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
< 	    if (*nextchar != '\0')
< 	    if (*nextchar != '\0')
< 		/* If we end this ARGV-element by taking the rest as an arg,
< 		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
< 		    fprintf (stderr, "%s: option requires an argument -- %c\n",
< 		 increment it again when taking next ARGV-elt as argument.  */
< #endif	/* _LIBC or not __GNU_LIBRARY__.  */
< 	    printf ("digits occur in two different argv-elements.\n");
< 	  printf ("option %c\n", c);
< 	  printf ("option a\n");
< 	  printf ("option b\n");
< 	  printf ("option c with value `%s'\n", optarg);
< 	  printf ("?? getopt returned character code 0%o ??\n", c);
<       printf ("non-option ARGV-elements: ");
<       printf ("\n");
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
< /* AIX requires this to be the first thing in the file. */
< #if defined (_AIX) && !defined (REGEX_MALLOC)
< #ifdef HAVE_CONFIG_H
< /* We used to test for `BSTRING' here, but only GCC and Emacs define
<    `BSTRING', as far as I know, and neither of them use this code.  */
< #if HAVE_STRING_H || STDC_HEADERS
< #ifdef STDC_HEADERS
< /* Define the syntax stuff for \<, \>, etc.  */
< #ifdef SYNTAX_TABLE
< #else /* not SYNTAX_TABLE */
< #define CHAR_SET_SIZE 256
< static char re_syntax_table[CHAR_SET_SIZE];
<    for (c = 'A'; c <= 'Z'; c++)
< #endif /* not SYNTAX_TABLE */
< #define SYNTAX(c) re_syntax_table[c]
<    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
<    STDC_HEADERS is defined, then autoconf has verified that the ctype
< #if ! defined (isascii) || defined (STDC_HEADERS)
< #define ISBLANK(c) (isascii (c) && isblank (c))
< #define ISBLANK(c) ((c) == ' ' || (c) == '\t')
< #define ISGRAPH(c) (isascii (c) && isgraph (c))
< #define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
< #define ISALNUM(c) (isascii (c) && isalnum (c))
< #define ISALPHA(c) (isascii (c) && isalpha (c))
< #define ISSPACE(c) (isascii (c) && isspace (c))
< /* We remove any previous definition of `SIGN_EXTEND_CHAR',
<    (Per Bothner suggested the basic approach.)  */
< #undef SIGN_EXTEND_CHAR
< #define SIGN_EXTEND_CHAR(c) ((signed char) (c))
< /* As in Harbison and Steele.  */
< #define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
< /* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
<    Because we sometimes use alloca, some routines have to be macros,
< #ifdef REGEX_MALLOC
< #define REGEX_ALLOCATE malloc
< #define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
< #else /* not REGEX_MALLOC  */
< #if HAVE_ALLOCA_H
< #else /* not __GNUC__ or HAVE_ALLOCA_H */
< #ifndef _AIX /* Already did AIX, up at the top.  */
< #endif /* not _AIX */
< #endif /* not HAVE_ALLOCA_H */ 
< #define REGEX_ALLOCATE alloca
< /* Assumes a `char *destination' variable.  */
< #define REGEX_REALLOCATE(source, osize, nsize)				\
<   (destination = (char *) alloca (nsize),				\
<    bcopy (source, destination, osize),					\
< #endif /* not REGEX_MALLOC */
< #define FIRST_STRING_P(ptr) 					\
< /* (Re)Allocate N items of type T using malloc, or fail.  */
< #define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
< #define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
< #define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
< #define BYTEWIDTH 8 /* In bits.  */
< #undef MAX               /****** added later *******/
< #define MAX(a, b) ((a) > (b) ? (a) : (b))
<    expressions.  Some opcodes are followed by argument bytes.  A
<    So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
<            for a bitmap saying which chars are in.  Bits in each byte
<            are ordered low-bit-first.  A character is in the set if its
<            bit is 1.  A character too large to have a bit in the map is
<         /* Analogously, for end of buffer/string.  */
<            is made to use it for a failure.  A `+' construct makes this
<            before the first repeat.  Also used as an intermediary kind
<            After matching N times, jump to the address upon failure.  */
< /* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
< #define STORE_NUMBER(destination, number)				\
<   do {									\
<     (destination)[0] = (number) & 0377;					\
<     (destination)[1] = (number) >> 8;					\
< /* Same as STORE_NUMBER, except increment DESTINATION to
<    the byte after where the number is stored.  Therefore, DESTINATION
< #define STORE_NUMBER_AND_INCR(destination, number)			\
<   do {									\
<     STORE_NUMBER (destination, number);					\
<     (destination) += 2;							\
< /* Put into DESTINATION a number stored in two contiguous bytes starting
< #define EXTRACT_NUMBER(destination, source)				\
<   do {									\
<     (destination) = *(source) & 0377;					\
<     (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
< #ifdef DEBUG
<   int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
< #ifndef EXTRACT_MACROS /* To debug the macros.  */
< #undef EXTRACT_NUMBER
< #define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
< #endif /* not EXTRACT_MACROS */
< #endif /* DEBUG */
< /* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
< #define EXTRACT_NUMBER_AND_INCR(destination, source)			\
<   do {									\
<     EXTRACT_NUMBER (destination, source);				\
<     (source) += 2; 							\
< #ifdef DEBUG
< #ifndef EXTRACT_MACROS
< #undef EXTRACT_NUMBER_AND_INCR
< #define EXTRACT_NUMBER_AND_INCR(dest, src) \
< #endif /* not EXTRACT_MACROS */
< #endif /* DEBUG */
< /* If DEBUG is defined, Regex prints many voluminous messages about what
<    interactively.  And if linked with the main program in `main.c' and
< #ifdef DEBUG
< #define DEBUG_STATEMENT(e) e
< #define DEBUG_PRINT1(x) if (debug) printf (x)
< #define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
< #define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
< #define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
< #define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
< #define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
<   while (i < (1 << BYTEWIDTH))
<           while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
<   putchar ('\n'); 
<    the START pointer into it and ending just before the pointer END.  */
<       printf ("(null)\n");
<       printf ("%d:\t", p - start);
< 		  /* Are we starting a range?  */
<       putchar ('\n');
<   printf ("%d:\tend of pattern.\n", p - start);
<   printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
<   printf ("re_nsub: %d\t", bufp->re_nsub);
<   printf ("regs_alloc: %d\t", bufp->regs_allocated);
<   printf ("can_be_null: %d\t", bufp->can_be_null);
<   printf ("newline_anchor: %d\n", bufp->newline_anchor);
<   printf ("no_sub: %d\t", bufp->no_sub);
<   printf ("not_bol: %d\t", bufp->not_bol);
<   printf ("not_eol: %d\t", bufp->not_eol);
<   printf ("syntax: %d\n", bufp->syntax);
< #else /* not DEBUG */
< #define DEBUG_STATEMENT(e)
< #define DEBUG_PRINT1(x)
< #define DEBUG_PRINT2(x1, x2)
< #define DEBUG_PRINT3(x1, x2, x3)
< #define DEBUG_PRINT4(x1, x2, x3, x4)
< #define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
< #define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
< #endif /* not DEBUG */
< reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
<    The argument SYNTAX is a bit mask comprised of the various bits
<     "No match",					/* REG_NOMATCH */
<     "Invalid regular expression",		/* REG_BADPAT */
<     "Invalid collation character",		/* REG_ECOLLATE */
<     "Trailing backslash",			/* REG_EESCAPE */
<     "Invalid back reference",			/* REG_ESUBREG */
<     "Unmatched [ or [^",			/* REG_EBRACK */
<     "Unmatched ( or \\(",			/* REG_EPAREN */
<     "Unmatched \\{",				/* REG_EBRACE */
<     "Invalid content of \\{\\}",		/* REG_BADBR */
<     "Invalid range end",			/* REG_ERANGE */
<     "Memory exhausted",				/* REG_ESPACE */
<     "Invalid preceding regular expression",	/* REG_BADRPT */
<     "Unmatched ) or \\)",			/* REG_ERPAREN */
<    if necessary.  Also cast from a signed character in the constant
< #define PATFETCH(c)							\
<   do {if (p == pend) return REG_EEND;					\
<     c = (unsigned char) *p++;						\
<     if (translate) c = translate[c]; 					\
< #define PATFETCH_RAW(c)							\
<   do {if (p == pend) return REG_EEND;					\
<     c = (unsigned char) *p++; 						\
< #define PATUNFETCH p--
<    `char *', to avoid warnings when a string constant is passed.  But
< #define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
< #define INIT_BUF_SIZE  32
< #define GET_BUFFER_SPACE(n)						\
<     while (b - bufp->buffer + (n) > bufp->allocated)			\
<       EXTEND_BUFFER ()
< #define BUF_PUSH(c)							\
<   do {									\
<     GET_BUFFER_SPACE (1);						\
<     *b++ = (unsigned char) (c);						\
< #define BUF_PUSH_2(c1, c2)						\
<   do {									\
<     GET_BUFFER_SPACE (2);						\
<     *b++ = (unsigned char) (c1);					\
<     *b++ = (unsigned char) (c2);					\
< /* As with BUF_PUSH_2, except for three bytes.  */
< #define BUF_PUSH_3(c1, c2, c3)						\
<   do {									\
<     GET_BUFFER_SPACE (3);						\
<     *b++ = (unsigned char) (c1);					\
<     *b++ = (unsigned char) (c2);					\
<     *b++ = (unsigned char) (c3);					\
< #define STORE_JUMP(op, loc, to) \
< #define STORE_JUMP2(op, loc, to, arg) \
< /* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
< #define INSERT_JUMP(op, loc, to) \
< /* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
< #define INSERT_JUMP2(op, loc, to, arg) \
< #define MAX_BUF_SIZE (1L << 16)
<    being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
< #define EXTEND_BUFFER()							\
<   do { 									\
<     unsigned char *old_buffer = bufp->buffer;				\
<     if (bufp->allocated == MAX_BUF_SIZE) 				\
<       return REG_ESIZE;							\
<     bufp->allocated <<= 1;						\
<     if (bufp->allocated > MAX_BUF_SIZE)					\
<       bufp->allocated = MAX_BUF_SIZE; 					\
<     bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
<     if (bufp->buffer == NULL)						\
<       return REG_ESPACE;						\
<     /* If the buffer moved, move all the pointers into it.  */		\
<     if (old_buffer != bufp->buffer)					\
<       {									\
<         b = (b - old_buffer) + bufp->buffer;				\
<         begalt = (begalt - old_buffer) + bufp->buffer;			\
<         if (fixup_alt_jump)						\
<           fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
<         if (laststart)							\
<           laststart = (laststart - old_buffer) + bufp->buffer;		\
<         if (pending_exact)						\
<           pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
<       }									\
< #define MAX_REGNUM 255
< /* But patterns can have more than `MAX_REGNUM' registers.  We just
<    be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
< #define INIT_COMPILE_STACK_SIZE 32
< #define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
< #define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
< #define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
< #define SET_LIST_BIT(c)                               \
<   (b[((unsigned char) (c)) / BYTEWIDTH]               \
<    |= 1 << (((unsigned char) c) % BYTEWIDTH))
< #define GET_UNSIGNED_NUMBER(num) 					\
<   { if (p != pend)							\
<      {									\
<        PATFETCH (c); 							\
<        while (ISDIGIT (c)) 						\
<          { 								\
<            if (num < 0)							\
<               num = 0;							\
<            num = num * 10 + c - '0'; 					\
<            if (p == pend) 						\
<               break; 							\
<            PATFETCH (c);						\
<          } 								\
<        } 								\
< #define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
< #define IS_CHAR_CLASS(string)						\
<    (STREQ (string, "alpha") || STREQ (string, "upper")			\
<     || STREQ (string, "lower") || STREQ (string, "digit")		\
<     || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
<     || STREQ (string, "space") || STREQ (string, "print")		\
<     || STREQ (string, "punct") || STREQ (string, "graph")		\
< /* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
<    Assumes the `allocated' (and perhaps `buffer') and `translate'
<    fields are set in BUFP on entry.
<    If it succeeds, results are put in BUFP (if it returns an error, the
<    contents of BUFP are undefined):
<      `syntax' is set to SYNTAX;
<      `re_nsub' is the number of subexpressions in PATTERN;
<   /* We fetch characters from PATTERN here.  Even though PATTERN is
<   /* A random tempory spot in PATTERN.  */
<   /* Address of the count-byte of the most recently inserted `exactn'
<   /* Address of start of the most recently finished expression.
<   /* Address of beginning of regexp, or inside of last group.  */
<   /* Address of the place where a forward jump should go to the end of
< #ifdef DEBUG
<   DEBUG_PRINT1 ("\nCompiling pattern: ");
<       putchar ('\n');
< #endif /* DEBUG */
<   compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
<     return REG_ESPACE;
<   compile_stack.size = INIT_COMPILE_STACK_SIZE;
<   /* Always count groups, whether or not bufp->no_sub is set.  */
< #if !defined (emacs) && !defined (SYNTAX_TABLE)
<           RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
<           bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
<       if (!bufp->buffer) return REG_ESPACE;
<       bufp->allocated = INIT_BUF_SIZE;
<       PATFETCH (c);
<                 || syntax & RE_CONTEXT_INDEP_ANCHORS
<               BUF_PUSH (begline);
<                 || syntax & RE_CONTEXT_INDEP_ANCHORS
<                BUF_PUSH (endline);
<           if ((syntax & RE_BK_PLUS_QM)
<               if (syntax & RE_CONTEXT_INVALID_OPS)
<                 return REG_BADRPT;
<             /* Are we optimizing this jump?  */
<                 PATFETCH (c);
<                     || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
<                 else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
<                     if (p == pend) return REG_EESCAPE;
<                     PATFETCH (c1);
<                         PATUNFETCH;
<                         PATUNFETCH;
<                     PATUNFETCH;
<                    But if we are at the `*' in the exact sequence `.*\n',
<                 /* Allocate the space for the jump.  */
<                 GET_BUFFER_SPACE (3);
<                    because laststart was nonzero.  And we've already
<                 if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
<                     && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
<                   { /* We have .*\n.  */
<                   /* Anything else.  */
<             GET_BUFFER_SPACE (3);
<                 /* At least one repetition is required, so insert a
<                 GET_BUFFER_SPACE (3);
<           BUF_PUSH (anychar);
<             if (p == pend) return REG_EBRACK;
< 	    GET_BUFFER_SPACE (34);
<                statement, so we only need one BUF_PUSH.  */
<             BUF_PUSH (*p == '^' ? charset_not : charset); 
<             BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
<             bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
<                 && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
<               SET_LIST_BIT ('\n');
<                 if (p == pend) return REG_EBRACK;
<                 PATFETCH (c);
<                 /* \ might escape characters inside [...] and [^...].  */
<                 if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
<                     if (p == pend) return REG_EESCAPE;
<                     PATFETCH (c1);
<                     SET_LIST_BIT (c1);
<                   return REG_ERANGE;
<                     PATFETCH (c1);
<                 else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
<                     char str[CHAR_CLASS_MAX_LENGTH + 1];
<                     PATFETCH (c);
<                     if (p == pend) return REG_EBRACK;
<                         PATFETCH (c);
<                             || c1 == CHAR_CLASS_MAX_LENGTH)
<                     str[c1] = '\0';
<                         if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
<                         PATFETCH (c);					
<                         if (p == pend) return REG_EBRACK;
<                         for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
<                             if (   (is_alnum  && ISALNUM (ch))
<                                 || (is_alpha  && ISALPHA (ch))
<                                 || (is_blank  && ISBLANK (ch))
<                                 || (is_graph  && ISGRAPH (ch))
<                                 || (is_space  && ISSPACE (ch))
<                             SET_LIST_BIT (ch);
<                           PATUNFETCH;
<                         SET_LIST_BIT ('[');
<                         SET_LIST_BIT (':');
<                     SET_LIST_BIT (c);
<           if (syntax & RE_NO_BK_PARENS)
<           if (syntax & RE_NO_BK_PARENS)
<         case '\n':
<           if (syntax & RE_NEWLINE_ALT)
<           if (syntax & RE_NO_BK_VBAR)
<            if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
<         case '\\':
<           if (p == pend) return REG_EESCAPE;
<           /* Do not translate the character after the \, so that we can
<              distinguish, e.g., \B from \b, even if we normally would
<              translate, e.g., B to b.  */
<           PATFETCH_RAW (c);
<               if (syntax & RE_NO_BK_PARENS)
<               if (COMPILE_STACK_FULL)
<                   RETALLOC (compile_stack.stack, compile_stack.size << 1,
<                   if (compile_stack.stack == NULL) return REG_ESPACE;
<               COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
<               COMPILE_STACK_TOP.fixup_alt_jump 
<               COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
<               COMPILE_STACK_TOP.regnum = regnum;
<                  groups inner to this one.  But do not push a
<               if (regnum <= MAX_REGNUM)
<                   COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
<                   BUF_PUSH_3 (start_memory, regnum, 0);
< 	      /* If we've reached MAX_REGNUM groups, then this open
<               if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
<               if (COMPILE_STACK_EMPTY)
<                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
<                   return REG_ERPAREN;
<                   BUF_PUSH (push_dummy_failure);
<               if (COMPILE_STACK_EMPTY)
<                 if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
<                   return REG_ERPAREN;
<                 begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
<                   = COMPILE_STACK_TOP.fixup_alt_jump
<                     ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
<                 laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
<                 this_group_regnum = COMPILE_STACK_TOP.regnum;
< 		/* If we've reached MAX_REGNUM groups, then this open
<                 if (this_group_regnum <= MAX_REGNUM)
<                       = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
<                     BUF_PUSH_3 (stop_memory, this_group_regnum,
<             case '|':					/* `\|'.  */
<               if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
<               GET_BUFFER_SPACE (3);
<                  which gets executed if it gets matched.  Adjust that
<                  jump jumps to the correct final destination.  A picture:
<               GET_BUFFER_SPACE (3);
<               /* If \{ is a literal.  */
<               if (!(syntax & RE_INTERVALS)
<                      /* If we're at `\{' and it's not the open-interval 
<                   || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
<                 /* At least (most) this many matches must be made.  */
<                     if (syntax & RE_NO_BK_BRACES)
<                       return REG_EBRACE;
<                 GET_UNSIGNED_NUMBER (lower_bound);
<                     GET_UNSIGNED_NUMBER (upper_bound);
<                     if (upper_bound < 0) upper_bound = RE_DUP_MAX;
<                 if (lower_bound < 0 || upper_bound > RE_DUP_MAX
<                     if (syntax & RE_NO_BK_BRACES)
<                       return REG_BADBR;
<                 if (!(syntax & RE_NO_BK_BRACES)) 
<                     if (c != '\\') return REG_EBRACE;
<                     PATFETCH (c);
<                     if (syntax & RE_NO_BK_BRACES)
<                       return REG_BADBR;
<                     if (syntax & RE_CONTEXT_INVALID_OPS)
<                       return REG_BADRPT;
<                      GET_BUFFER_SPACE (3);
<                      GET_BUFFER_SPACE (nbytes);
<                             for the relative address.  But we are
<                PATFETCH (c);	
<                if (!(syntax & RE_NO_BK_BRACES))
<                    if (p > pattern  &&  p[-1] == '\\')
<               BUF_PUSH (at_dot);
<               PATFETCH (c);
<               BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
<               PATFETCH (c);
<               BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
<               BUF_PUSH (wordchar);
<               BUF_PUSH (notwordchar);
<               BUF_PUSH (wordbeg);
<               BUF_PUSH (wordend);
<               BUF_PUSH (wordbound);
<             case 'B':
<               BUF_PUSH (notwordbound);
<               BUF_PUSH (begbuf);
<             case '\'':
<               BUF_PUSH (endbuf);
<               if (syntax & RE_NO_BK_REFS)
<                 return REG_ESUBREG;
<               BUF_PUSH_2 (duplicate, c1);
<               if (syntax & RE_BK_PLUS_QM)
<               /* You might think it would be useful for \ to mean
<               c = TRANSLATE (c);
< 	      || *pending_exact == (1 << BYTEWIDTH) - 1
< 	      || ((syntax & RE_BK_PLUS_QM)
< 		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
< 	      || ((syntax & RE_INTERVALS)
<                   && ((syntax & RE_NO_BK_BRACES)
<                       : (p[0] == '\\' && p[1] == '{'))))
< 	      BUF_PUSH_2 (exactn, 0);
< 	  BUF_PUSH (c);
<   if (!COMPILE_STACK_EMPTY) 
<     return REG_EPAREN;
< #ifdef DEBUG
<       DEBUG_PRINT1 ("\nCompiled pattern: \n");
< #endif /* DEBUG */
< /* Store OP at LOC followed by two-byte integer parameter ARG.  */
<   STORE_NUMBER (loc + 1, arg);
< /* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
<   STORE_NUMBER (loc + 1, arg1);
<   STORE_NUMBER (loc + 3, arg2);
<    for OP followed by two-byte integer parameter ARG.  */
< /* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
< /* P points to just after a ^ in PATTERN.  Return true if that ^ comes
<   boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
<        /* After a subexpression?  */
<        (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
<        /* After an alternative?  */
<     || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
<   boolean next_backslash = *next == '\\';
<        /* Before a subexpression?  */
<        (syntax & RE_NO_BK_PARENS ? *next == ')'
<        /* Before an alternative?  */
<     || (syntax & RE_NO_BK_VBAR ? *next == '|'
< /* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
<    ending characters (inclusive) in the compiled pattern B.
<     return REG_ERANGE;
<     return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
<       SET_LIST_BIT (TRANSLATE (this_char));
<    REGEX_ALLOCATE.  */
< #ifndef INIT_FAILURE_ALLOC
< #define INIT_FAILURE_ALLOC 5
<    exactly that if always used MAX_FAILURE_SPACE each time we failed.
< #define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
< #define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
< #define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
< #define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
< #define INIT_FAIL_STACK()						\
<   do {									\
<     fail_stack.stack = (fail_stack_elt_t *)				\
<       REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
< 									\
<     if (fail_stack.stack == NULL)					\
<       return -2;							\
< 									\
<     fail_stack.size = INIT_FAILURE_ALLOC;				\
<     fail_stack.avail = 0;						\
< /* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
<    REGEX_REALLOCATE requires `destination' be declared.   */
< #define DOUBLE_FAIL_STACK(fail_stack)					\
<   ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
<    ? 0									\
<    : ((fail_stack).stack = (fail_stack_elt_t *)				\
<         REGEX_REALLOCATE ((fail_stack).stack, 				\
<           (fail_stack).size * sizeof (fail_stack_elt_t),		\
<           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
< 									\
<       (fail_stack).stack == NULL					\
<       ? 0								\
<       : ((fail_stack).size <<= 1, 					\
< /* Push PATTERN_OP on FAIL_STACK. 
< #define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
<   ((FAIL_STACK_FULL ()							\
<     && !DOUBLE_FAIL_STACK (fail_stack))					\
<     ? 0									\
<     : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
<    value.  Assumes the variable `fail_stack'.  Probably should only
<    be called from within `PUSH_FAILURE_POINT'.  */
< #define PUSH_FAILURE_ITEM(item)						\
< /* The complement operation.  Assumes `fail_stack' is nonempty.  */
< #define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
< #ifdef DEBUG
< #define DEBUG_PUSH PUSH_FAILURE_ITEM
< #define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
< #define DEBUG_PUSH(item)
< #define DEBUG_POP(item_addr)
<    num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
<    Does `return FAILURE_CODE' if runs out of memory.  */
< #define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
<   do {									\
<     char *destination;							\
<     /* Must be int, so when we don't save any registers, the arithmetic	\
<        of 0 + -1 isn't done as unsigned.  */				\
<     int this_reg;							\
<     									\
<     DEBUG_STATEMENT (failure_id++);					\
<     DEBUG_STATEMENT (nfailure_points_pushed++);				\
<     DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
<     DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
<     DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
< 									\
<     DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
<     DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
< 									\
<     /* Ensure we have enough space allocated for what we will push.  */	\
<     while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
<       {									\
<         if (!DOUBLE_FAIL_STACK (fail_stack))			\
<           return failure_code;						\
< 									\
<         DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
< 		       (fail_stack).size);				\
<         DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
<       }									\
< 									\
<     /* Push the info, starting with the registers.  */			\
<     DEBUG_PRINT1 ("\n");						\
< 									\
<     for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
<          this_reg++)							\
<       {									\
< 	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
<         DEBUG_STATEMENT (num_regs_pushed++);				\
< 									\
< 	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
<         PUSH_FAILURE_ITEM (regstart[this_reg]);				\
<                                                                         \
< 	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
<         PUSH_FAILURE_ITEM (regend[this_reg]);				\
< 									\
< 	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
<         DEBUG_PRINT2 (" match_null=%d",					\
<                       REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
<         DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
<         DEBUG_PRINT2 (" matched_something=%d",				\
<                       MATCHED_SOMETHING (reg_info[this_reg]));		\
<         DEBUG_PRINT2 (" ever_matched=%d",				\
<                       EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
< 	DEBUG_PRINT1 ("\n");						\
<         PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
<       }									\
< 									\
<     DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
<     PUSH_FAILURE_ITEM (lowest_active_reg);				\
< 									\
<     DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
<     PUSH_FAILURE_ITEM (highest_active_reg);				\
< 									\
<     DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
<     DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
<     PUSH_FAILURE_ITEM (pattern_place);					\
< 									\
<     DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
<     DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
< 				 size2);				\
<     DEBUG_PRINT1 ("'\n");						\
<     PUSH_FAILURE_ITEM (string_place);					\
< 									\
<     DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
<     DEBUG_PUSH (failure_id);						\
< #ifdef DEBUG
< #define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
< #define NUM_FAILURE_ITEMS						\
<   ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
< #define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
< /* Pops what PUSH_FAIL_STACK pushes.
<      PAT -- the saved pattern position.
<      REGSTART, REGEND -- arrays of string positions.
<    Also assumes the variables `fail_stack' and (if debugging), `bufp',
< #define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
< {									\
<   DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
<   int this_reg;								\
<   const unsigned char *string_temp;					\
< 									\
<   assert (!FAIL_STACK_EMPTY ());					\
< 									\
<   /* Remove failure points and point to how many regs pushed.  */	\
<   DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
<   DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
<   DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
< 									\
<   assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
< 									\
<   DEBUG_POP (&failure_id);						\
<   DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
< 									\
<   /* If the saved string location is NULL, it came from an		\
<      on_failure_keep_string_jump opcode, and we want to throw away the	\
<      saved NULL, thus retaining our current position in the string.  */	\
<   string_temp = POP_FAILURE_ITEM ();					\
<   if (string_temp != NULL)						\
<     str = (const char *) string_temp;					\
< 									\
<   DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
<   DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
<   DEBUG_PRINT1 ("'\n");							\
< 									\
<   pat = (unsigned char *) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
<   DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
< 									\
<   /* Restore register info.  */						\
<   high_reg = (unsigned) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
< 									\
<   low_reg = (unsigned) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
< 									\
<   for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
<     {									\
<       DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
< 									\
<       reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
<       DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
< 									\
<       regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
<       DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
< 									\
<       regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
<       DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
<     }									\
< 									\
<   DEBUG_STATEMENT (nfailure_points_popped++);				\
< } /* POP_FAILURE_POINT */
<    BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
<    The caller must supply the address of a (1 << BYTEWIDTH)-byte data
<    area as BUFP->fastmap.
< #ifndef REGEX_MALLOC
<   /* Assume that each path through the pattern can be null until
<   INIT_FAIL_STACK ();
<   bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
<   while (p != pend || !FAIL_STACK_EMPTY ())
< #ifdef SWITCH_ENUM_BUG
<           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
< 	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
< 	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
< 	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
< 	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	    if (SYNTAX (j) == Sword)
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	    if (SYNTAX (j) != Sword)
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
<             fastmap['\n'] = 0;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	    if (SYNTAX (j) == (enum syntaxcode) k)
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	    if (SYNTAX (j) != (enum syntaxcode) k)
<       /* All cases after this match the empty string.  These end with
<           EXTRACT_NUMBER_AND_INCR (j, p);
<           EXTRACT_NUMBER_AND_INCR (j, p);
<           if (!FAIL_STACK_EMPTY () 
<           EXTRACT_NUMBER_AND_INCR (j, p);
<               if (!PUSH_PATTERN_OP (p + j, fail_stack))
<               EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
<           EXTRACT_NUMBER_AND_INCR (k, p);
< /* Set REGS to hold NUM_REGS registers, storing them in STARTS and
<    ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
<    this memory for recording register information.  STARTS and ENDS
<    PATTERN_BUFFER will allocate its own register data, without
<       bufp->regs_allocated = REGS_REALLOCATE;
<       bufp->regs_allocated = REGS_UNALLOCATED;
< /* Using the compiled pattern in BUFP->buffer, first tries to match the
<    STARTPOS, then at STARTPOS + 1, and so on.
<    RANGE is how far to scan while trying to match.  RANGE = 0 means try
<    only at STARTPOS; in general, the last start tried is STARTPOS +
<    RANGE.
<    and STRING2 that matched the entire BUFP->buffer and its contained
<   /* Check for out-of-range STARTPOS.  */
<   /* Fix up RANGE if it might eventually take us outside
< 	      if (!fastmap[(unsigned char) TRANSLATE (c)])
<          zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
< #define MATCH_NULL_UNSET_VALUE 3
< #define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
< #define IS_ACTIVE(R)  ((R).bits.is_active)
< #define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
< #define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
<    for the subexpressions which we are currently inside.  Also records
< #define SET_REGS_MATCHED()						\
<   do									\
<     {									\
<       unsigned r;							\
<       for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
<         {								\
<           MATCHED_SOMETHING (reg_info[r])				\
<             = EVER_MATCHED_SOMETHING (reg_info[r])			\
<             = 1;							\
<         }								\
<     }									\
< #define POINTER_TO_OFFSET(ptr)						\
< #define REG_UNSET_VALUE ((char *) -1)
< #define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
< #define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
< #define PREFETCH()							\
<   while (d == dend)						    	\
<     {									\
<       /* End of string2 => fail.  */					\
<       if (dend == end_match_2) 						\
<         goto fail;							\
<       /* End of string1 => advance to string2.  */ 			\
<       d = string2;						        \
<       dend = end_match_2;						\
< #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
< #define AT_STRINGS_END(d) ((d) == end2)	
< #define WORDCHAR_P(d)							\
<   (SYNTAX ((d) == end1 ? *string2					\
<            : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
< #define AT_WORD_BOUNDARY(d)						\
<   (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
<    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
< #ifdef REGEX_MALLOC
< #define FREE_VAR(var) if (var) free (var); var = NULL
< #define FREE_VARIABLES()						\
<   do {									\
<     FREE_VAR (fail_stack.stack);					\
<     FREE_VAR (regstart);						\
<     FREE_VAR (regend);							\
<     FREE_VAR (old_regstart);						\
<     FREE_VAR (old_regend);						\
<     FREE_VAR (best_regstart);						\
<     FREE_VAR (best_regend);						\
<     FREE_VAR (reg_info);						\
<     FREE_VAR (reg_dummy);						\
<     FREE_VAR (reg_info_dummy);						\
< #else /* not REGEX_MALLOC */
< #define FREE_VARIABLES() alloca (0)
< #endif /* not REGEX_MALLOC */
<    NUM_FAILURE_ITEMS above.  And the value for the lowest register must
< #define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
< #define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
< /* re_match_2 matches the compiled pattern in BUFP against the
<    If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
< #ifdef DEBUG
<   unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
<   unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
<   /* Logically, this is `best_regend[0]'.  But we don't want to have to
<      else (see below).  Also, we never need info about register 0 for
< #ifdef DEBUG
<   DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
<   INIT_FAIL_STACK ();
<       regstart = REGEX_TALLOC (num_regs, const char *);
<       regend = REGEX_TALLOC (num_regs, const char *);
<       old_regstart = REGEX_TALLOC (num_regs, const char *);
<       old_regend = REGEX_TALLOC (num_regs, const char *);
<       best_regstart = REGEX_TALLOC (num_regs, const char *);
<       best_regend = REGEX_TALLOC (num_regs, const char *);
<       reg_info = REGEX_TALLOC (num_regs, register_info_type);
<       reg_dummy = REGEX_TALLOC (num_regs, const char *);
<       reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
<           FREE_VARIABLES ();
< #ifdef REGEX_MALLOC
<          `FREE_VARIABLES' doesn't try to free them.  */
< #endif /* REGEX_MALLOC */
<       FREE_VARIABLES ();
<      start_memory/stop_memory has been seen for. Also initialize the
<         = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
<       REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
<       IS_ACTIVE (reg_info[mcnt]) = 0;
<       MATCHED_SOMETHING (reg_info[mcnt]) = 0;
<       EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
<   DEBUG_PRINT1 ("The compiled pattern is: ");
<   DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
<   DEBUG_PRINT1 ("The string to match is: `");
<   DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
<   DEBUG_PRINT1 ("'\n");
<       DEBUG_PRINT2 ("\n0x%x: ", p);
<           DEBUG_PRINT1 ("end of pattern ... ");
<               DEBUG_PRINT1 ("backtracking.\n");
<               if (!FAIL_STACK_EMPTY ())
< 	        	                == MATCHING_IN_FIRST_STRING);
<                       || (!same_str_p && !MATCHING_IN_FIRST_STRING))
<                       DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
<                   DEBUG_PRINT1 ("Restoring best registers.\n");
<           DEBUG_PRINT1 ("Accepting match.\n");
<               if (bufp->regs_allocated == REGS_UNALLOCATED)
<                   regs->num_regs = MAX (RE_NREGS, num_regs + 1);
<                   regs->start = TALLOC (regs->num_regs, regoff_t);
<                   regs->end = TALLOC (regs->num_regs, regoff_t);
<                   bufp->regs_allocated = REGS_REALLOCATE;
<               else if (bufp->regs_allocated == REGS_REALLOCATE)
<                       RETALLOC (regs->start, regs->num_regs, regoff_t);
<                       RETALLOC (regs->end, regs->num_regs, regoff_t);
<                   regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
<           FREE_VARIABLES ();
<           DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
<           DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
<           mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
<           DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
< #ifdef SWITCH_ENUM_BUG
<           DEBUG_PRINT1 ("EXECUTING no_op.\n");
<           DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
< 	  SET_REGS_MATCHED ();
<           DEBUG_PRINT1 ("EXECUTING anychar.\n");
<           if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
<               || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
<           SET_REGS_MATCHED ();
<           DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
<             DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
< 	    c = TRANSLATE (*d); /* The character to match.  */
< 	    if (c < (unsigned) (*p * BYTEWIDTH)
< 		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
< 	    SET_REGS_MATCHED ();
< 	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
<           if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
<             REG_MATCH_NULL_STRING_P (reg_info[*p]) 
<           old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
< 	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
< 	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
<           IS_ACTIVE (reg_info[*p]) = 1;
<           MATCHED_SOMETHING (reg_info[*p]) = 0;
<           if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
< 	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
<           old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
< 	  DEBUG_PRINT2 ("      old_regend: %d\n", 
< 	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
<           IS_ACTIVE (reg_info[*p]) = 0;
<               lowest_active_reg = NO_LOWEST_ACTIVE_REG;
<               highest_active_reg = NO_HIGHEST_ACTIVE_REG;
<               while (r > 0 && !IS_ACTIVE (reg_info[r]))
<                   lowest_active_reg = NO_LOWEST_ACTIVE_REG;
<                   highest_active_reg = NO_HIGHEST_ACTIVE_REG;
<           if ((!MATCHED_SOMETHING (reg_info[*p])
<                     EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                      Also restore the registers for inner groups for,
<                   if (EVER_MATCHED_SOMETHING (reg_info[*p]))
<                       EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                   PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
< 	/* \<digit> has been turned into a `duplicate' command which is
< 	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
< 		/* At end of register contents => success */
<           DEBUG_PRINT1 ("EXECUTING begline.\n");
<           if (AT_STRINGS_BEG (d))
<           else if (d[-1] == '\n' && bufp->newline_anchor)
<           DEBUG_PRINT1 ("EXECUTING endline.\n");
<           if (AT_STRINGS_END (d))
<           else if ((d == end1 ? *string2 : *d) == '\n'
<           DEBUG_PRINT1 ("EXECUTING begbuf.\n");
<           if (AT_STRINGS_BEG (d))
<           DEBUG_PRINT1 ("EXECUTING endbuf.\n");
< 	  if (AT_STRINGS_END (d))
<         /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
<            matching `foo\nbar' against `.*\n'.  The .* matches the foo;
<            then the . fails against the \n.  But the next thing we want
<            to do is match the \n against the \n; if we restored the
<            Because this is used only in specific cases, we don't need to
<           DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
<           EXTRACT_NUMBER_AND_INCR (mcnt, p);
<           DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
<           PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
<           DEBUG_PRINT1 ("EXECUTING on_failure_jump");
<           EXTRACT_NUMBER_AND_INCR (mcnt, p);
<           DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
<              For example, in \(a*\)*\1, we need the preceding group,
<              and in \(\(a*\)b*\)\2, we need the inner group.  */
<              the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
<               if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
<           DEBUG_PRINT1 (":\n");
<           PUSH_FAILURE_POINT (p + mcnt, d, -2);
<         /* A smart repeat ends with `maybe_pop_jump'.
<           EXTRACT_NUMBER_AND_INCR (mcnt, p);
<           DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
<                (e.g., if the string was `ab').  But instead of trying to
< 		/* Consider what happens when matching ":\(.*\)"
<                 DEBUG_PRINT1
<                   ("  End of pattern: change to `pop_failure_jump'.\n");
<                   = *p2 == (unsigned char) endline ? '\n' : p2[2];
<                     DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
< 		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
< 			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
<                         DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
<               DEBUG_PRINT1 ("  Match => jump.\n");
<             DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
<             POP_FAILURE_POINT (sdummy, pdummy,
< 	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
<           DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
<           DEBUG_PRINT2 ("(to 0x%x).\n", p);
<           DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
<           DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
<           PUSH_FAILURE_POINT (0, 0, -2);
<         /* At the end of an alternative, we need to push a dummy failure
<           DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
<           PUSH_FAILURE_POINT (0, 0, -2);
<            After that, handle like `on_failure_jump'.  */
<           EXTRACT_NUMBER (mcnt, p + 2);
<           DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
<           /* Originally, this is how many times we HAVE to succeed.  */
<                STORE_NUMBER_AND_INCR (p, mcnt);
<                DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
<               DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
<           EXTRACT_NUMBER (mcnt, p + 2);
<           DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
<           /* Originally, this is how many times we CAN jump.  */
<                STORE_NUMBER (p + 2, mcnt);
<             DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
<             EXTRACT_NUMBER_AND_INCR (mcnt, p);
<             EXTRACT_NUMBER_AND_INCR (mcnt, p);
<             DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
< 	    STORE_NUMBER (p1, mcnt);
<           DEBUG_PRINT1 ("EXECUTING wordbound.\n");
<           if (AT_WORD_BOUNDARY (d))
<           DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
< 	  if (AT_WORD_BOUNDARY (d))
<           DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
< 	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
<           DEBUG_PRINT1 ("EXECUTING wordend.\n");
< 	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
<               && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
<           DEBUG_PRINT1 ("EXECUTING before_dot.\n");
<  	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
<           DEBUG_PRINT1 ("EXECUTING at_dot.\n");
<  	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
<           DEBUG_PRINT1 ("EXECUTING after_dot.\n");
<           if (PTR_CHAR_POS ((unsigned char *) d) <= point)
<           DEBUG_PRINT1 ("EXECUTING at_dot.\n");
< 	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
<           DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
< 	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
<           SET_REGS_MATCHED ();
<           DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
< 	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
< 	  SET_REGS_MATCHED ();
<           DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
<           if (!WORDCHAR_P (d))
< 	  SET_REGS_MATCHED ();
<           DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
< 	  if (WORDCHAR_P (d))
<           SET_REGS_MATCHED ();
<       if (!FAIL_STACK_EMPTY ())
< 	{ /* A restart point is known.  Restore to that state.  */
<           DEBUG_PRINT1 ("\nFAIL:\n");
<           POP_FAILURE_POINT (d, p,
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<   FREE_VARIABLES ();
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                   /* Break if it's the beginning of an n-th alternative
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<               EXTRACT_NUMBER (mcnt, p1 - 2);
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<       assert (reg_no > 0 && reg_no <= MAX_REGNUM);
<       if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
<         REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
<       EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<       EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<       if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
<       /* All other opcodes mean we cannot match the empty string.  */
< /* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
<    compiles PATTERN (of length SIZE) and puts the result in BUFP.
<    Assumes the `allocated' (and perhaps `buffer') and `translate' fields
<    are set in BUFP on entry.
<   bufp->regs_allocated = REGS_UNALLOCATED;
<   /* And GNU code determines whether or not to get register information
< /* Entry points compatible with 4.2 BSD regex library.  We don't define
< /* BSD has one and only one pattern buffer.  */
<       re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
<      `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
<        REG_EXTENDED bit in CFLAGS is set; otherwise, to
<        RE_SYNTAX_POSIX_BASIC;
<      `newline_anchor' to REG_NEWLINE being set in CFLAGS;
<      `re_nsub' to the number of subexpressions in PATTERN.
<    PATTERN is the address of the pattern string.
<    CFLAGS is a series of bits which affect compilation.
<      Also, regexec will try a match beginning after every newline.
<      If REG_ICASE is set, then we considers upper- and lowercase
<      If REG_NOSUB is set, then when PREG is passed to regexec, that
<       RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
<   if (cflags & REG_ICASE)
<       preg->translate = (char *) malloc (CHAR_SET_SIZE);
<         return (int) REG_ESPACE;
<       for (i = 0; i < CHAR_SET_SIZE; i++)
<       syntax |= RE_HAT_LISTS_NOT_NEWLINE;
<   preg->no_sub = !!(cflags & REG_NOSUB);
<      unmatched close-group: both are REG_EPAREN.  */
<   if (ret == REG_ERPAREN) ret = REG_EPAREN;
<    If NMATCH is zero or REG_NOSUB was set in the cflags argument to
<    `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
<    least NMATCH elements, and we set them to the offsets of the
<    EFLAGS specifies `execution flags' which affect matching: if
<    REG_NOTBOL is set, then ^ does not match at the beginning of the
<    We return 0 if we find a match and REG_NOMATCH if not.  */
<   private_preg.not_bol = !!(eflags & REG_NOTBOL);
<       regs.start = TALLOC (nmatch, regoff_t);
<       regs.end = TALLOC (nmatch, regoff_t);
<         return (int) REG_NOMATCH;
<   return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
<    Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
< #ifdef STDC_HEADERS
< #if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
< #undef ISALPHA
< #undef ISSPACE
< #undef ISALNUM
< #undef ISGRAPH
< #define ISALPHA(C) (isascii(C) && isalpha(C))
< #define ISSPACE(C) (isascii(C) && isspace(C))
< #define ISALNUM(C) (isascii(C) && isalnum(C))
< #define ISGRAPH(C) (isascii(C) && isgraph(C))
< #define ISALPHA(C) isalpha(C)
< #define ISSPACE(C) isspace(C)
< #define ISALNUM(C) isalnum(C)
< #define ISGRAPH(C) isgraph(C)
< #define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
< #define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
< #define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
< #define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
<   if ((index) >= (nalloc))			  \
<     {						  \
<       while ((index) >= (nalloc))		  \
< 	(nalloc) *= 2;				  \
<       REALLOC(p, t, nalloc);			  \
< #ifdef DEBUG
<   else if (t < NOTCHAR)
< 	case BACKREF: s = "BACKREF"; break;
< 	case BEGLINE: s = "BEGLINE"; break;
< 	case BEGWORD: s = "BEGWORD"; break;
< 	case QMARK: s = "QMARK"; break;
< 	case STAR: s = "STAR"; break;
< 	case CAT: s = "CAT"; break;
< 	case LPAREN: s = "LPAREN"; break;
< 	case RPAREN: s = "RPAREN"; break;
< #endif /* DEBUG */
<   return c[b / INTBITS] & 1 << b % INTBITS;
<   c[b / INTBITS] |= 1 << b % INTBITS;
<   c[b / INTBITS] &= ~(1 << b % INTBITS);
<   for (i = 0; i < CHARCLASS_INTS; ++i)
<   for (i = 0; i < CHARCLASS_INTS; ++i)
<   for (i = 0; i < CHARCLASS_INTS; ++i)
<   for (i = 0; i < CHARCLASS_INTS; ++i)
< /* A pointer to the current dfa is kept here during parsing. */
<   REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
< /* Lexical analyzer.  All the dross that deals with the obnoxious
< #define FETCH(c, eoferr)   	      \
<   {			   	      \
<     if (! lexleft)	   	      \
<       if (eoferr != 0)	   	      \
< 	dfaerror(eoferr);  	      \
<       else		   	      \
< 	return END;	   	      \
<     (c) = (unsigned char) *lexptr++;  \
<     --lexleft;		   	      \
< FUNC(is_alpha, ISALPHA)
< FUNC(is_space, ISSPACE)
< FUNC(is_alnum, ISALNUM)
< FUNC(is_graph, ISGRAPH)
<   /* Basic plan: We fetch a character.  If it's a backslash,
< 	case '\\':
< 	    dfaerror("Unfinished \\ escape");
< 	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
< 	      || lasttok == LPAREN
< 	    return lasttok = BEGLINE;
< 	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
< 	      || (syntax_bits & RE_NO_BK_PARENS
< 		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
< 	      || (syntax_bits & RE_NO_BK_VBAR
< 		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
< 	      || ((syntax_bits & RE_NEWLINE_ALT)
< 	          && lexleft > 0 && *lexptr == '\n'))
< 	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
< 	      return lasttok = BACKREF;
< 	    return lasttok = BEGWORD;
< 	case 'B':
< 	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
< 	  return lasttok = QMARK;
< 	  return lasttok = STAR;
< 	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
< 	  if (!(syntax_bits & RE_INTERVALS))
< 	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
< 	  if (!(syntax_bits & RE_NO_BK_BRACES))
< 	      if (c != '\\')
< 	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
< 	case '\n':
< 	      || !(syntax_bits & RE_NEWLINE_ALT))
< 	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
< 	  return lasttok = LPAREN;
< 	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
< 	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
< 	  return lasttok = RPAREN;
< 	    clrbit('\n', ccl);
< 	    clrbit('\0', ccl);
< 	  for (c2 = 0; c2 < NOTCHAR; ++c2)
< 	    if (ISALNUM(c2))
< 	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
< 		      for (c2 = 0; c2 < NOTCHAR; ++c2)
< 	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
< 		      if (c2 == '\\'
< 			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
< 	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
< 		clrbit('\n', ccl);
< 	  if (case_fold && ISALPHA(c))
< /* Add the given token to the parse tree, maintaining the depth count and
<   REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
<     case QMARK:
<     case STAR:
<     case CAT:
<      closure QMARK
<      closure STAR
<      BACKREF
<      BEGLINE
<      BEGWORD
<   if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
<       || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
<   else if (tok == LPAREN)
<       if (tok != RPAREN)
<     case QMARK:
<     case STAR:
<     case CAT:
<   while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
< 	  addtok(QMARK);
< 	    addtok(CAT);
< 	    addtok(QMARK);
< 	    addtok(CAT);
<   while (tok != RPAREN && tok != OR && tok >= 0)
<       addtok(CAT);
<   addtok(CAT);
<   REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
<   MALLOC(d->states[i].elems.elems, position, s->nelem);
<     else if (d->tokens[s->elems[j].index] == BACKREF)
< 	d->states[i].constraint = NO_CONSTRAINT;
<   MALLOC(visited, int, d->tindex);
<     if (d->tokens[s->elems[i].index] >= NOTCHAR
< 	&& d->tokens[s->elems[i].index] != BACKREF
< 	  case BEGLINE:
< 	    p.constraint &= BEGLINE_CONSTRAINT;
< 	    p.constraint &= ENDLINE_CONSTRAINT;
< 	  case BEGWORD:
< 	    p.constraint &= BEGWORD_CONSTRAINT;
< 	    p.constraint &= ENDWORD_CONSTRAINT;
< 	    p.constraint &= LIMWORD_CONSTRAINT;
< 	    p.constraint &= NOTLIMWORD_CONSTRAINT;
<    Note that at this point, we're pretending constructs like \< are real
<    Nullable:  A node is nullable if it is at the root of a regexp that can
<    * A QMARK or STAR node is nullable.
<    * A PLUS node is nullable if its argument is nullable.
<    * A CAT node is nullable if both its arguments are nullable.
<    * An OR node is nullable if either argument is nullable.
<    * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
<    * The firstpos of a CAT node is the firstpos of the left argument, union
<    * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
<    * The lastpos of a CAT node is the lastpos of its right argument, union
<    a string matching the regexp.  At this point we consider special symbols
<    * Every node in the firstpos of the argument of a STAR or PLUS node is in
<    * Every node in the firstpos of the second argument of a CAT node is in
<    Because of the postfix representation of the parse tree, the depth-first
<   position *firstpos;		/* Array where firstpos elements are stored. */
<   position *lastpos;		/* Array where lastpos elements are stored. */
< #ifdef DEBUG
<   fprintf(stderr, "dfaanalyze:\n");
<   putc('\n', stderr);
<   MALLOC(nullable, int, d->depth);
<   MALLOC(nfirstpos, int, d->depth);
<   MALLOC(firstpos, position, d->nleaves);
<   MALLOC(nlastpos, int, d->depth);
<   MALLOC(lastpos, position, d->nleaves);
<   MALLOC(nalloc, int, d->tindex);
<   MALLOC(merged.elems, position, d->nleaves);
<   CALLOC(d->follows, position_set, d->tindex);
< #ifdef DEBUG
<       case STAR:
< 	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
<       case QMARK:
< 	/* A QMARK or STAR node is automatically nullable. */
<       case CAT:
< 	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
< 	/* The firstpos of a CAT node is the firstpos of the first argument,
< 	/* The lastpos of a CAT node is the lastpos of the second argument,
< 	/* A CAT node is nullable if both arguments are nullable. */
< 	/* An OR node is nullable if either argument is nullable. */
< 	/* Anything else is a nonempty position.  (Note that special
< 	   constructs like \< are treated as nonempty strings here;
< 	   Backreferences have to get a real position so we can detect
< 	   transitions on them later.  But they are nullable. */
< 	*nullable++ = d->tokens[i] == BACKREF;
< 	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
< 	/* Allocate the follow set for this position. */
< 	MALLOC(d->follows[i].elems, position, nalloc[i]);
< #ifdef DEBUG
<       putc('\n', stderr);
<       fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
<       fprintf(stderr, "\n lastpos:");
<       putc('\n', stderr);
<     if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
< #ifdef DEBUG
< 	putc('\n', stderr);
< 	  REALLOC(d->follows[i].elems, position, merged.nelem);
<   /* Build the initial state. */
<   MALLOC(d->states, dfa_state, d->salloc);
<   position_set grps[NOTCHAR];	/* As many as will ever be needed. */
<   charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
<       for (i = 0; i < NOTCHAR; ++i)
< 	if (ISALNUM(i))
<       setbit('\n', newline);
<       if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
< 	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
< 	    clrbit('\n', matches);
< 	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
< 	    for (j = 0; j < CHARCLASS_INTS; ++j)
< 	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
< 	    for (j = 0; j < CHARCLASS_INTS; ++j)
< 	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
< 	    for (j = 0; j < CHARCLASS_INTS; ++j)
< 	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
< 	  if (j == CHARCLASS_INTS)
< 	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
< 	  for (k = 0; k < CHARCLASS_INTS; ++k)
< 	  for (k = 0; k < CHARCLASS_INTS; ++k)
< 	      MALLOC(grps[ngrps].elems, position, d->nleaves);
< 	  MALLOC(grps[ngrps].elems, position, d->nleaves);
<   MALLOC(follows.elems, position, d->nleaves);
<   MALLOC(tmp.elems, position, d->nleaves);
<       for (i = 0; i < NOTCHAR; ++i)
< 	if (i == '\n')
< 	else if (ISALNUM(i))
<     for (i = 0; i < NOTCHAR; ++i)
<       if (tstbit('\n', labels[i]))
<       for (j = 0; j < CHARCLASS_INTS; ++j)
<       if (j < CHARCLASS_INTS)
<       for (j = 0; j < CHARCLASS_INTS; ++j)
< 	for (k = 0; k < INTBITS; ++k)
< 	      int c = j * INTBITS + k;
< 	      if (c == '\n')
< 	      else if (ISALNUM(c))
< 	      else if (c < NOTCHAR)
<   if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
<   if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
<   if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
<   MALLOC(trans, int, NOTCHAR);
<   for (i = 0; i < NOTCHAR; ++i)
< 	REALLOC(d->realtrans, int *, d->tralloc + 1);
< 	REALLOC(d->fails, int *, d->tralloc);
< 	REALLOC(d->success, int, d->tralloc);
< 	REALLOC(d->newlines, int, d->tralloc);
<   d->newlines[s] = trans['\n'];
<   trans['\n'] = -1;
<   if (ACCEPTING(s, *d))
<   CALLOC(d->realtrans, int *, d->tralloc + 1);
<   CALLOC(d->fails, int *, d->tralloc);
<   MALLOC(d->success, int, d->tralloc);
<   MALLOC(d->newlines, int, d->tralloc);
<    character after the match, or NULL if none is found.  Begin points to
<   static sbit[NOTCHAR];	/* Table for anding with d->success. */
<       for (i = 0; i < NOTCHAR; ++i)
< 	if (i == '\n')
< 	else if (ISALNUM(i))
<   *end = '\n';
<       if (count && (char *) p <= end && p[-1] == '\n')
<       if (p[-1] == '\n' && newline)
<   MALLOC(d->charclasses, charclass, d->calloc);
<   MALLOC(d->tokens, token, d->talloc);
<    The sequences calculated for the various types of node (in pseudo ANSI c)
< 	STAR	ZERO		ZERO		ZERO		ZERO
< 	QMARK	ZERO		ZERO		ZERO		ZERO
< 	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
<    Break ties in favor of infrequent letters (choosing 'zzz' in preference to
<    And. . .is it here or someplace that we might ponder "optimizations" such as
<    Are optimizable r.e.'s likely to be used in real-life situations
<   for (cp = lookin; *cp != '\0'; ++cp)
<   new[len] = '\0';
<   /* Add the new string. */
<   for (lcp = left; *lcp != '\0'; ++lcp)
< 	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
<   mp->left[0] = mp->right[0] = mp->is[0] = '\0';
<       mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
< #ifdef DEBUG
<   fprintf(stderr, "dfamust:\n");
<   putc('\n', stderr);
< 	case LPAREN:
< 	case RPAREN:
< 	case BEGLINE:
< 	case BEGWORD:
< 	case BACKREF:
< 	case STAR:
< 	case QMARK:
< 	      lmp->is[0] = '\0';
< 	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
< 	    lmp->left[i] = '\0';
< 	    lmp->right[j] = '\0';
< 	  mp->is[0] = '\0';
< 	case CAT:
< 	    if (lmp->right[0] != '\0' &&
< 		rmp->left[0] != '\0')
< 	    if (lmp->is[0] != '\0')
< 	    if (rmp->is[0] == '\0')
< 	      lmp->right[0] = '\0';
< 	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
< 	      lmp->is[0] = '\0';
< 	  else if (t == '\0')
< 	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
< #ifdef DEBUG
<       fprintf(stderr, "\n  in:");
< 	fprintf(stderr, " \"%s\"", mp->in[i]);
<       fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
<       fprintf(stderr, "  left: \"%s\"\n", mp->left);
<       fprintf(stderr, "  right: \"%s\"\n", mp->right);
< 		  Written August 1989 by Mike Haertel.
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<    to one discovered by Beate Commentz-Walter, although it is not identical.
<    See "A String Matching Algorithm Fast on the Average," Technical Report,
<    IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
<    Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
<    String Matching:  An Aid to Bibliographic Search," CACM June 1975,
< #ifdef STDC_HEADERS
< #undef RE_DUP_MAX
< #define INT_MAX 2147483647
< #define UCHAR_MAX 255
< #ifdef HAVE_MEMCHR
< #define NCHAR (UCHAR_MAX + 1)
< /* Balanced tree of edges and labels leaving a given trie node. */
<   struct trie *fail;		/* Aho-Corasick failure function. */
<   unsigned char delta[NCHAR];	/* Delta table for rapid search. */
<   struct trie *next[NCHAR];	/* Table of children of the root. */
<   int mind2;			/* Used in Boyer-Moore search for one string. */
< /* Allocate and initialize a keyword set object, returning an opaque
<   kwset->mind = INT_MAX;
< /* Add the given string to the contents of the keyword set.  Return NULL
< 	  /* Back up the tree fixing the balance flags. */
< /* Compute the Aho-Corasick failure function for the trie nodes referenced
< /* Return true if A has every label in B. */
<   unsigned char delta[NCHAR];
<   struct trie *last, *next[NCHAR];
<     for (i = 0; i < NCHAR; ++i)
<     for (i = 0; i < NCHAR; ++i)
<       /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
<       for (i = 0; i < NCHAR; ++i)
< 	for (i = 0; i < NCHAR; ++i)
< 	for (i = 0; i < NCHAR; ++i)
<     for (i = 0; i < NCHAR; ++i)
<     for (i = 0; i < NCHAR; ++i)
< but WITHOUT ANY WARRANTY; without even the implied warranty of
< MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
< Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
< /* This is just to get __GNU_LIBRARY__ defined.  */
< #if defined (_LIBC) || !defined (__GNU_LIBRARY__)
< #define DEFAULT_ALIGNMENT  \
< /* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
<    But in fact it might be less smart and round addresses to as much as
<    DEFAULT_ROUNDING.  So we prepare for it to do that.  */
< #define DEFAULT_ROUNDING (sizeof (union fooround))
< #define CALL_CHUNKFUN(h, size) \
<   (((h) -> use_extra_arg) \
<    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
< #define CALL_FREEFUN(h, old_chunk) \
<   do { \
<     if ((h) -> use_extra_arg) \
<       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
<     else \
<       (*(h)->freefun) ((old_chunk)); \
<    Objects start on multiples of ALIGNMENT (0 means use default).
<     alignment = DEFAULT_ALIGNMENT;
<       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
<       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
< 		    + 4 + DEFAULT_ROUNDING - 1)
< 		   & ~(DEFAULT_ROUNDING - 1));
<   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
<     alignment = DEFAULT_ALIGNMENT;
<       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
<       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
< 		    + 4 + DEFAULT_ROUNDING - 1)
< 		   & ~(DEFAULT_ROUNDING - 1));
<   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
< /* Allocate a new current chunk for the obstack *H
<   /* Allocate and initialize the new chunk.  */
<   new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
<   if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
<      But not if that chunk might contain an empty object.  */
<       CALL_FREEFUN (h, old_chunk);
< /* Return nonzero if object OBJ has been allocated from obstack H.
< /* Free objects in obstack H, including OBJ and everything allocate
<    more recently than OBJ.  If OBJ is zero, free everything in H.  */
<    This is the first one, called from non-ANSI code.  */
<      But there can be an empty object at that address
<       CALL_FREEFUN (h, lp);
< /* This function is used from ANSI code.  */
<      But there can be an empty object at that address
<       CALL_FREEFUN (h, lp);
< /* These function definitions do not work with non-ANSI preprocessors;
< #endif	/* _LIBC or not __GNU_LIBRARY__.  */
<    but WITHOUT ANY WARRANTY; without even the implied warranty of
<    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<    Written August 1992 by Mike Haertel. */
< #ifdef STDC_HEADERS
< #undef RE_DUP_MAX
< #define UCHAR_MAX 255
< #ifdef HAVE_MEMCHR
< #if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
< #define ISALNUM(C) (isascii(C) && isalnum(C))
< #define ISALNUM(C) isalnum(C)
< #define NCHAR (UCHAR_MAX + 1)
< #define WCHAR(C) (ISALNUM(C) || (C) == '_')
< /* DFA compiled regexp. */
<   static char trans[NCHAR];
<     for (i = 0; i < NCHAR; ++i)
< /* If the DFA turns out to have some set of fixed strings one of
<   re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
<   dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
<      for the DFA matcher that will quickly throw out cases that won't work.
<      Then if DFA succeeds we do some hairy stuff using the regex matcher
< 	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
< 	 BUG: Using [A-Za-z_] is locale-dependent!  */
< 	strcpy(n, "^\\(");
< 	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
< 	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
< 	strcpy(n + i, "\\)$");
<       re_set_syntax(RE_SYNTAX_POSIX_EGREP);
<       dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
<       re_set_syntax(RE_SYNTAX_EGREP);
<       dfasyntax(RE_SYNTAX_EGREP, match_icase);
<      for the DFA matcher that will quickly throw out cases that won't work.
<      Then if DFA succeeds we do some hairy stuff using the regex matcher
< 	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
< 	 BUG: Using [A-Za-z_] is locale-dependent!  */
< 	strcpy(n, "(^|[^0-9A-Za-z_])(");
< 	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
<   static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
< 	     run it through DFA. */
< 	  end = memchr(beg, '\n', buflim - beg);
< 	  while (beg > buf && beg[-1] != '\n')
< 	  /* No good fixed strings; start with DFA. */
< 	  end = memchr(beg, '\n', buflim - beg);
< 	  while (beg > buf && beg[-1] != '\n')
<       /* If we've made it to this point, this means DFA has seen
< 		if ((start == 0 || !WCHAR(beg[start - 1]))
< 		    && (len == end - beg || !WCHAR(beg[start + len])))
<       for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
< 	  if (beg > buf && beg[-1] != '\n')
< 	  if (beg + len < buf + size && beg[len] != '\n')
< 	    if (try > buf && WCHAR((unsigned char) try[-1]))
< 	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
<   if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
<   while (beg > buf && beg[-1] != '\n')
---
> target1: 
