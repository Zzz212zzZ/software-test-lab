1,1591d0
<    Copyright (C) 1992 Free Software Foundation, Inc.
<    the Free Software Foundation; either version 2, or (at your option)
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<    Written July 1992 by Mike Haertel.  */
< #define GREP 1
< #define STDC_HEADERS 1
< #define HAVE_STRING_H 1
< #define HAVE_SYS_PARAM_H 1
< #define HAVE_UNISTD_H 1
< #define HAVE_ALLOCA_H 1
< #define HAVE_GETPAGESIZE 1
< #define HAVE_MEMCHR 1
< #define HAVE_STRERROR 1
< #define HAVE_VALLOC 1
< #define HAVE_WORKING_MMAP 1
< #define flag_stdlib 1
< #define flag_systypes 1
< #define flag_string 1
< #define flag_memory 1
< #define flag_strings 1
< #define flag_systypes 1
<     fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
<     fprintf(stderr, "%s: %s\n", prog, mesg);
<   errseen = 1;
<   exit(2);
< #define flag_systypes 1
<       initialized = 1;
<       bufsalloc = MAX(8192, getpagesize());
<       bufalloc = 5 * bufsalloc;
<       /* The 1 byte of overflow is a kludge for dfaexec(), which
<       buffer = valloc(bufalloc + 1);
<       bufmapped = 1;
<       bufoffset = lseek(fd, 0, 1);
< 	bufsalloc *= 2;
<       bufalloc = 5 * bufsalloc;
<       nbuffer = valloc(bufalloc + 1);
<       if (maddr == (caddr_t) -1)
< 	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
< 	 but it doesn't, at least not on a Sun running 4.1.
< 	 In fact, it actually slows us down about 30%! */
<     if (*beg == '\n')
<   fwrite(beg, 1, lim - beg, stdout);
<       if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
< 	  while (p > bp && p[-1] != '\n');
< 	  nl = memchr(p, '\n', beg - p);
< 	  prline(p, nl + 1, '-');
< 	  p = nl + 1;
< 	  if ((nl = memchr(p, '\n', lim - p)) != 0)
<   used = 1;
<       if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
< 	  nlines += 1;
<       for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
< 	  while (beg > bufbeg && beg[-1] != '\n');
< static char version[] = "GNU grep version 2.0";
< #define USAGE \
<   "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
<   exit(2);
<    If we find it, install it in compile and execute, and return 1.  */
< 	return 1;
<     prog = strrchr(prog, '/') + 1;
<   while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
<       case '1':
<       case '2':
<       case '3':
<       case '4':
<       case '5':
<       case '6':
<       case '7':
<       case '8':
<       case '9':
< 	out_before = 10 * out_before + opt - '0';
< 	out_after = 10 * out_after + opt - '0';
< 	out_before = out_after = 2;
< 	fprintf(stderr, "%s\n", version);
< 	out_byte = 1;
< 	out_quiet = 1;
< 	count_matches = 1;
< 	keys = xrealloc(keys, keycc + cc + 1);
< 	  keys[keycc++] = '\n';
< 	keyfound = 1;
< 	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
< 	  keys[keycc++] = '\n';
< 	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
< 	      keys = xrealloc(keys, keyalloc *= 2);
< 	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
< 	keyfound = 1;
< 	no_filenames = 1;
< 	match_icase = 1;
< 	out_quiet = 1;
< 	list_files = -1;
< 	out_quiet = 1;
< 	list_files = 1;
< 	out_line = 1;
< 	out_quiet = 1;
< 	suppress_errors = 1;
< 	out_invert = 1;
< 	match_words = 1;
< 	match_lines = 1;
<   if (argc - optind > 1 && !no_filenames)
<     out_file = 1;
<   status = 1;
< 		printf("%d\n", count);
< 		if (list_files == 1)
< 		  printf("%s\n", filename);
< 	    else if (list_files == -1)
< 	      printf("%s\n", filename);
< 	printf("%d\n", count);
< 	  if (list_files == 1)
< 	    printf("(standard input)\n");
<       else if (list_files == -1)
< 	printf("(standard input)\n");
<   exit(errseen ? 2 : status);
<    Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
<    Free Software Foundation; either version 2, or (at your option) any
<    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
< #define flag_config 1
< #if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
< #define flag_alloca 1
< /* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
< #define flag_stdlib 1
<    long-named option.  Because this is not POSIX.2 compliant, it is
< /* XXX 1003.2 says this must be 1 before any call.  */
< int opterr = 1;
<    as if it were the argument of an option with character code 1.
< #define flag_string 1
<      Start processing options with ARGV-element 1 (since ARGV-element 0
<       first_nonopt = last_nonopt = optind = 1;
<   if (nextchar == NULL || *nextchar == '\0')
< 		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
< 		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
<       if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
< 	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
< 	  return 1;
<       nextchar = (argv[optind] + 1
< 		  + (longopts != NULL && argv[optind][1] == '-'));
< 	   && (argv[optind][1] == '-' || long_only))
< 		exact = 1;
< 	      ambig = 1;
< 	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
< 		optarg = s + 1;
< 		      if (argv[optind - 1][1] == '-')
< 				 "%s: option `--%s' doesn't allow an argument\n",
< 			     "%s: option `%c%s' doesn't allow an argument\n",
< 			     argv[0], argv[optind - 1][0], pfound->name);
< 	  else if (pfound->has_arg == 1)
< 		    fprintf (stderr, "%s: option `%s' requires an argument\n",
< 			     argv[0], argv[optind - 1]);
<       if (!long_only || argv[optind][1] == '-'
< 	      if (argv[optind][1] == '-')
< 		fprintf (stderr, "%s: unrecognized option `--%s'\n",
< 		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
<     if (*nextchar == '\0')
< 	    if (c < 040 || c >= 0177)
< 	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
< 	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
< 	    /* 1003.2 specifies the format of this message.  */
< 	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
<     if (temp[1] == ':')
< 	if (temp[2] == ':')
< 	    if (*nextchar != '\0')
< 	    if (*nextchar != '\0')
< 		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
< 		    /* 1003.2 specifies the format of this message.  */
< 		    fprintf (stderr, "%s: option requires an argument -- %c\n",
<   while (1)
<       int this_option_optind = optind ? optind : 1;
<       c = getopt (argc, argv, "abc:d:0123456789");
< 	case '1':
< 	case '2':
< 	case '3':
< 	case '4':
< 	case '5':
< 	case '6':
< 	case '7':
< 	case '8':
< 	case '9':
< 	    printf ("digits occur in two different argv-elements.\n");
< 	  printf ("option %c\n", c);
< 	  printf ("option a\n");
< 	  printf ("option b\n");
< 	  printf ("option c with value `%s'\n", optarg);
< 	  printf ("?? getopt returned character code 0%o ??\n", c);
<       printf ("\n");
<    version 0.12.
<    (Implements POSIX draft P10003.2/D11.2, except for
<    Copyright (C) 1993 Free Software Foundation, Inc.
<    the Free Software Foundation; either version 2, or (at your option)
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
< #define flag_systypes 1
< #define flag_config 1
< #define flag_string 1
< #define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
< #define flag_strings 1
< #define flag_stdlib 1
< /* Define the syntax stuff for \<, \>, etc.  */
<    commands in re_match_2.  */
< #define Sword 1
< #define CHAR_SET_SIZE 256
<    for (c = '0'; c <= '9'; c++)
<    done = 1;
<    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
<    Defining isascii to 1 should let any compiler worth its salt
< #define isascii(c) 1
< #define ISBLANK(c) ((c) == ' ' || (c) == '\t')
< #define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
< #define flag_alloca 1
< #define REGEX_REALLOCATE(source, osize, nsize)				\
<   (destination = (char *) alloca (nsize),				\
<    bcopy (source, destination, osize),					\
< /* True if `size1' is non-NULL and PTR is pointing anywhere inside
<    `string1' or just past its end.  This works if PTR is NULL, which is
< #define FIRST_STRING_P(ptr) 					\
<   (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
< #define BYTEWIDTH 8 /* In bits.  */
< #define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
< #define true 1
<    So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
<    `exactn' we use here must also be 1.  */
<   exactn = 1,
<            bit is 1.  A character too large to have a bit in the map is
<            of re_match_2.)  */
< #define STORE_NUMBER(destination, number)				\
<   do {									\
<     (destination)[0] = (number) & 0377;					\
<     (destination)[1] = (number) >> 8;					\
< #define STORE_NUMBER_AND_INCR(destination, number)			\
<   do {									\
<     STORE_NUMBER (destination, number);					\
<     (destination) += 2;							\
< #define EXTRACT_NUMBER(destination, source)				\
<   do {									\
<     (destination) = *(source) & 0377;					\
<     (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
<   int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
<   *dest = *source & 0377;
<   *dest += temp << 8;
< #define EXTRACT_NUMBER_AND_INCR(destination, source)			\
<   do {									\
<     EXTRACT_NUMBER (destination, source);				\
<     (source) += 2; 							\
<   *source += 2;
< #define EXTRACT_NUMBER_AND_INCR(dest, src) \
< #define DEBUG_PRINT1(x) if (debug) printf (x)
< #define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
< #define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
< #define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
< #define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
< #define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
<   if (debug) print_double_string (w, s1, sz1, s2, sz2)
<   while (i < (1 << BYTEWIDTH))
<           printchar (i - 1);
<           while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
<               was_a_range = 1;
<               printchar (i - 1);
<   putchar ('\n'); 
<   int mcnt, mcnt2;
<       printf ("(null)\n");
<       printf ("%d:\t", p - start);
<             register int c, last = -100;
< 	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
<             for (c = 0; c < 256; c++)
< 	      if (c / 8 < *p
< 		  && (p[1 + (c/8)] & (1 << (c % 8))))
< 		  if (last + 1 == c && ! in_range)
< 		      in_range = 1;
< 		  else if (last + 1 != c && in_range)
< 	    p += 1 + *p;
<           extract_number_and_incr (&mcnt2, &p);
< 	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
<           extract_number_and_incr (&mcnt2, &p);
< 	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
<           extract_number_and_incr (&mcnt2, &p);
< 	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
<           printf ("?%d", *(p-1));
<       putchar ('\n');
<   printf ("%d:\tend of pattern.\n", p - start);
<   printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
<   printf ("re_nsub: %d\t", bufp->re_nsub);
<   printf ("regs_alloc: %d\t", bufp->regs_allocated);
<   printf ("can_be_null: %d\t", bufp->can_be_null);
<   printf ("newline_anchor: %d\n", bufp->newline_anchor);
<   printf ("no_sub: %d\t", bufp->no_sub);
<   printf ("not_bol: %d\t", bufp->not_bol);
<   printf ("not_eol: %d\t", bufp->not_eol);
<   printf ("syntax: %d\n", bufp->syntax);
< print_double_string (where, string1, size1, string2, size2)
<     const char *string1;
<     const char *string2;
<     int size1;
<     int size2;
<           for (this_char = where - string1; this_char < size1; this_char++)
<             printchar (string1[this_char]);
<           where = string2;    
<       for (this_char = where - string2; this_char < size2; this_char++)
<         printchar (string2[this_char]);
< #define DEBUG_PRINT1(x)
< #define DEBUG_PRINT2(x1, x2)
< #define DEBUG_PRINT3(x1, x2, x3)
< #define DEBUG_PRINT4(x1, x2, x3, x4)
< #define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
<     "Unmatched ( or \\(",			/* REG_EPAREN */
<     "Unmatched \\{",				/* REG_EBRACE */
<     "Invalid content of \\{\\}",		/* REG_BADBR */
<     "Unmatched ) or \\)",			/* REG_ERPAREN */
< static void store_op1 (), store_op2 ();
< static void insert_op1 (), insert_op2 ();
< #define PATFETCH(c)							\
<   do {if (p == pend) return REG_EEND;					\
<     c = (unsigned char) *p++;						\
<     if (translate) c = translate[c]; 					\
< #define PATFETCH_RAW(c)							\
<   do {if (p == pend) return REG_EEND;					\
<     c = (unsigned char) *p++; 						\
< #define INIT_BUF_SIZE  32
< #define GET_BUFFER_SPACE(n)						\
<     while (b - bufp->buffer + (n) > bufp->allocated)			\
< #define BUF_PUSH(c)							\
<   do {									\
<     GET_BUFFER_SPACE (1);						\
<     *b++ = (unsigned char) (c);						\
< /* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
< #define BUF_PUSH_2(c1, c2)						\
<   do {									\
<     GET_BUFFER_SPACE (2);						\
<     *b++ = (unsigned char) (c1);					\
<     *b++ = (unsigned char) (c2);					\
< /* As with BUF_PUSH_2, except for three bytes.  */
< #define BUF_PUSH_3(c1, c2, c3)						\
<   do {									\
<     GET_BUFFER_SPACE (3);						\
<     *b++ = (unsigned char) (c1);					\
<     *b++ = (unsigned char) (c2);					\
<     *b++ = (unsigned char) (c3);					\
< #define STORE_JUMP(op, loc, to) \
<   store_op1 (op, loc, (to) - (loc) - 3)
< #define STORE_JUMP2(op, loc, to, arg) \
<   store_op2 (op, loc, (to) - (loc) - 3, arg)
< #define INSERT_JUMP(op, loc, to) \
<   insert_op1 (op, loc, (to) - (loc) - 3, b)
< /* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
< #define INSERT_JUMP2(op, loc, to, arg) \
<   insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
<    into the pattern are two bytes long.  So if 2^16 bytes turns out to
< #define MAX_BUF_SIZE (1L << 16)
< #define EXTEND_BUFFER()							\
<   do { 									\
<     unsigned char *old_buffer = bufp->buffer;				\
<     if (bufp->allocated == MAX_BUF_SIZE) 				\
<       return REG_ESIZE;							\
<     bufp->allocated <<= 1;						\
<     if (bufp->allocated > MAX_BUF_SIZE)					\
<       bufp->allocated = MAX_BUF_SIZE; 					\
<     bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
<     if (bufp->buffer == NULL)						\
<       return REG_ESPACE;						\
<     /* If the buffer moved, move all the pointers into it.  */		\
<     if (old_buffer != bufp->buffer)					\
<       {									\
<         b = (b - old_buffer) + bufp->buffer;				\
<         begalt = (begalt - old_buffer) + bufp->buffer;			\
<         if (fixup_alt_jump)						\
<           fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
<         if (laststart)							\
<           laststart = (laststart - old_buffer) + bufp->buffer;		\
<         if (pending_exact)						\
<           pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
<       }									\
< #define MAX_REGNUM 255
<    be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
< #define INIT_COMPILE_STACK_SIZE 32
< #define SET_LIST_BIT(c)                               \
<   (b[((unsigned char) (c)) / BYTEWIDTH]               \
<    |= 1 << (((unsigned char) c) % BYTEWIDTH))
< #define GET_UNSIGNED_NUMBER(num) 					\
<   { if (p != pend)							\
<      {									\
<        PATFETCH (c); 							\
<        while (ISDIGIT (c)) 						\
<          { 								\
<            if (num < 0)							\
<               num = 0;							\
<            num = num * 10 + c - '0'; 					\
<            if (p == pend) 						\
<               break; 							\
<            PATFETCH (c);						\
<          } 								\
<        } 								\
< #define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
< #define IS_CHAR_CLASS(string)						\
<    (STREQ (string, "alpha") || STREQ (string, "upper")			\
<     || STREQ (string, "lower") || STREQ (string, "digit")		\
<     || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
<     || STREQ (string, "space") || STREQ (string, "print")		\
<     || STREQ (string, "punct") || STREQ (string, "graph")		\
<   register unsigned char c, c1;
<   const char *p1;
<   DEBUG_PRINT1 ("\nCompiling pattern: ");
<       putchar ('\n');
<                    p == pattern + 1
<             /* 1 means zero (many) matches is allowed.  */
<                interval operators with these because of, e.g., `a{2}*',
<                 else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
<                     PATFETCH (c1);
<                     if (!(c1 == '+' || c1 == '?'))
<                     c = c1;
<                    But if we are at the `*' in the exact sequence `.*\n',
<                 assert (p - 1 > pattern);
<                 GET_BUFFER_SPACE (3);
<                 if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
<                     && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
<                   { /* We have .*\n.  */
<                   STORE_JUMP (maybe_pop_jump, b, laststart - 3);
<                 b += 3;
<             /* On failure, jump from laststart to b + 3, which will be the
<             GET_BUFFER_SPACE (3);
<                          laststart, b + 3);
<             b += 3;
<                 GET_BUFFER_SPACE (3);
<                 INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
<                 b += 3;
<                opcode, the length count, and the bitset; 34 bytes in all.  */
< 	    GET_BUFFER_SPACE (34);
<             p1 = p;
<             BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
<             bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
<             if ((re_opcode_t) b[-2] == charset_not
<               SET_LIST_BIT ('\n');
<                 /* \ might escape characters inside [...] and [^...].  */
<                 if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
<                     PATFETCH (c1);
<                     SET_LIST_BIT (c1);
<                 if (c == ']' && p != p1 + 1)
<                     && !(p - 2 >= pattern && p[-2] == '[') 
<                     && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
<                 else if (p[0] == '-' && p[1] != ']')
<                     PATFETCH (c1);
<                     char str[CHAR_CLASS_MAX_LENGTH + 1];
<                     c1 = 0;
<                             || c1 == CHAR_CLASS_MAX_LENGTH)
<                         str[c1++] = c;
<                     str[c1] = '\0';
<                         for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
<                         c1++;
<                         while (c1--)    
<             while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
<               b[-1]--; 
<             b += b[-1];
<         case '\n':
<         case '\\':
<           /* Do not translate the character after the \, so that we can
<              distinguish, e.g., \B from \b, even if we normally would
<                   RETALLOC (compile_stack.stack, compile_stack.size << 1,
<                   compile_stack.size <<= 1;
<                 = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
<                   COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
<                   BUF_PUSH_3 (start_memory, regnum, 0);
<                      `push_dummy_failure' in `re_match_2'.  */
<                   STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
<                    as in `(ab)c(de)' -- the second group is #2.  */
<                     ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
<                     BUF_PUSH_3 (stop_memory, this_group_regnum,
<             case '|':					/* `\|'.  */
<               GET_BUFFER_SPACE (3);
<               INSERT_JUMP (on_failure_jump, begalt, b + 6);
<               b += 3;
<               GET_BUFFER_SPACE (3);
<               b += 3;
<               /* If \{ is a literal.  */
<                      /* If we're at `\{' and it's not the open-interval 
<                   || (p - 2 == pattern  &&  p == pend))
<                 int lower_bound = -1, upper_bound = -1;
<                 beg_interval = p - 1;
<                   /* Interval such as `{1}' => match exactly once. */
<                     if (c != '\\') return REG_EBRACE;
<                    all; jump from `laststart' to `b + 3', which will be
<                      GET_BUFFER_SPACE (3);
<                      INSERT_JUMP (jump, laststart, b + 3);
<                      b += 3;
<                     `upper_bound' is 1, though.)  */
<                    { /* If the upper bound is > 1, we need to insert
<                      unsigned nbytes = 10 + (upper_bound > 1) * 10;
<                      INSERT_JUMP2 (succeed_n, laststart,
<                                    b + 5 + (upper_bound > 1) * 5,
<                      b += 5;
<                         before the `succeed_n'.  The `5' is the last two
<                         bytes of this `set_number_at', plus 3 bytes of
<                      insert_op2 (set_number_at, laststart, 5, lower_bound, b);
<                      b += 5;
<                      if (upper_bound > 1)
<                             jump back only `upper_bound - 1' times.  */
<                          STORE_JUMP2 (jump_n, b, laststart + 5,
<                                       upper_bound - 1);
<                          b += 5;
<                             parameter of the `jump_n'; that is `b-2' as
<                             `laststart+3' the number to set, the source
<                             so everything is getting moved up by 5.
<                             Conclusion: (b - 2) - (laststart + 3) + 5,
<                          insert_op2 (set_number_at, laststart, b - laststart,
<                                      upper_bound - 1, b);
<                          b += 5;
<                    if (p > pattern  &&  p[-1] == '\\')
<               BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
<               BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
<             case '\'':
<             case '1': case '2': case '3': case '4': case '5':
<             case '6': case '7': case '8': case '9':
<               c1 = c - '0';
<               if (c1 > regnum)
<               if (group_in_compile_stack (compile_stack, c1))
<               BUF_PUSH_2 (duplicate, c1);
<               /* You might think it would be useful for \ to mean
<               || pending_exact + *pending_exact + 1 != b
< 	      || *pending_exact == (1 << BYTEWIDTH) - 1
< 		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
<                       : (p[0] == '\\' && p[1] == '{'))))
< 	      BUF_PUSH_2 (exactn, 0);
< 	      pending_exact = b - 1;
<       DEBUG_PRINT1 ("\nCompiled pattern: \n");
< store_op1 (op, loc, arg)
<   STORE_NUMBER (loc + 1, arg);
< /* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
< store_op2 (op, loc, arg1, arg2)
<     int arg1, arg2;
<   STORE_NUMBER (loc + 1, arg1);
<   STORE_NUMBER (loc + 3, arg2);
< insert_op1 (op, loc, arg, end)
<   register unsigned char *pto = end + 3;
<   store_op1 (op, loc, arg);
< /* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
< insert_op2 (op, loc, arg1, arg2, end)
<     int arg1, arg2;
<   register unsigned char *pto = end + 5;
<   store_op2 (op, loc, arg1, arg2);
<   const char *prev = p - 2;
<   boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
<   boolean next_backslash = *next == '\\';
<   const char *next_next = p + 1 < pend ? p + 1 : NULL;
<   for (this_element = compile_stack.avail - 1;  
<    starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
<   range_start = ((unsigned char *) p)[-2];
<      (assuming 8-bit characters), we would otherwise go into an infinite
<    re_match_2 use a failure stack.  These have to be macros because of
< #define INIT_FAILURE_ALLOC 5
< int re_max_failures = 2000;
< /* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
< #define INIT_FAIL_STACK()						\
<   do {									\
<     fail_stack.stack = (fail_stack_elt_t *)				\
<       REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
< 									\
<     if (fail_stack.stack == NULL)					\
<       return -2;							\
< 									\
<     fail_stack.size = INIT_FAILURE_ALLOC;				\
<     fail_stack.avail = 0;						\
<    Return 1 if succeeds, and 0 if either ran out of memory
< #define DOUBLE_FAIL_STACK(fail_stack)					\
<   ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
<    ? 0									\
<    : ((fail_stack).stack = (fail_stack_elt_t *)				\
<         REGEX_REALLOCATE ((fail_stack).stack, 				\
<           (fail_stack).size * sizeof (fail_stack_elt_t),		\
<           ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
< 									\
<       (fail_stack).stack == NULL					\
<       ? 0								\
<       : ((fail_stack).size <<= 1, 					\
<          1)))
<    Return 1 if was able to do so and 0 if ran out of memory allocating
< #define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
<   ((FAIL_STACK_FULL ()							\
<     && !DOUBLE_FAIL_STACK (fail_stack))					\
<     ? 0									\
<     : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
<        1))
< #define PUSH_FAILURE_ITEM(item)						\
< #define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
<   do {									\
<     char *destination;							\
<     /* Must be int, so when we don't save any registers, the arithmetic	\
<        of 0 + -1 isn't done as unsigned.  */				\
<     int this_reg;							\
<     									\
<     DEBUG_STATEMENT (failure_id++);					\
<     DEBUG_STATEMENT (nfailure_points_pushed++);				\
<     DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
<     DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
<     DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
< 									\
<     DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
<     DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
< 									\
<     /* Ensure we have enough space allocated for what we will push.  */	\
<     while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
<       {									\
<         if (!DOUBLE_FAIL_STACK (fail_stack))			\
<           return failure_code;						\
< 									\
<         DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
< 		       (fail_stack).size);				\
<         DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
<       }									\
< 									\
<     /* Push the info, starting with the registers.  */			\
<     DEBUG_PRINT1 ("\n");						\
< 									\
<     for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
<          this_reg++)							\
<       {									\
< 	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
<         DEBUG_STATEMENT (num_regs_pushed++);				\
< 									\
< 	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
<         PUSH_FAILURE_ITEM (regstart[this_reg]);				\
<                                                                         \
< 	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
<         PUSH_FAILURE_ITEM (regend[this_reg]);				\
< 									\
< 	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
<         DEBUG_PRINT2 (" match_null=%d",					\
<                       REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
<         DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
<         DEBUG_PRINT2 (" matched_something=%d",				\
<                       MATCHED_SOMETHING (reg_info[this_reg]));		\
<         DEBUG_PRINT2 (" ever_matched=%d",				\
<                       EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
< 	DEBUG_PRINT1 ("\n");						\
<         PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
<       }									\
< 									\
<     DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
<     PUSH_FAILURE_ITEM (lowest_active_reg);				\
< 									\
<     DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
<     PUSH_FAILURE_ITEM (highest_active_reg);				\
< 									\
<     DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
<     DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
<     PUSH_FAILURE_ITEM (pattern_place);					\
< 									\
<     DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
<     DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
< 				 size2);				\
<     DEBUG_PRINT1 ("'\n");						\
<     PUSH_FAILURE_ITEM (string_place);					\
< 									\
<     DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
<     DEBUG_PUSH (failure_id);						\
< #define NUM_REG_ITEMS  3
< #define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
< #define NUM_NONREG_ITEMS 4
< #define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
< #define NUM_FAILURE_ITEMS						\
<   ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
<    `pend', `string1', `size1', `string2', and `size2'.  */
< #define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
< {									\
<   DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
<   int this_reg;								\
<   const unsigned char *string_temp;					\
< 									\
<   assert (!FAIL_STACK_EMPTY ());					\
< 									\
<   /* Remove failure points and point to how many regs pushed.  */	\
<   DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
<   DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
<   DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
< 									\
<   assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
< 									\
<   DEBUG_POP (&failure_id);						\
<   DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
< 									\
<   /* If the saved string location is NULL, it came from an		\
<      on_failure_keep_string_jump opcode, and we want to throw away the	\
<      saved NULL, thus retaining our current position in the string.  */	\
<   string_temp = POP_FAILURE_ITEM ();					\
<   if (string_temp != NULL)						\
<     str = (const char *) string_temp;					\
< 									\
<   DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
<   DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
<   DEBUG_PRINT1 ("'\n");							\
< 									\
<   pat = (unsigned char *) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
<   DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
< 									\
<   /* Restore register info.  */						\
<   high_reg = (unsigned) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
< 									\
<   low_reg = (unsigned) POP_FAILURE_ITEM ();				\
<   DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
< 									\
<   for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
<     {									\
<       DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
< 									\
<       reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
<       DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
< 									\
<       regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
<       DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
< 									\
<       regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
<       DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
<     }									\
< 									\
<   DEBUG_STATEMENT (nfailure_points_popped++);				\
<    BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
<    The caller must supply the address of a (1 << BYTEWIDTH)-byte data
<    Returns 0 if we succeed, -2 if an internal error.   */
<   bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
<   bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
<            `can_be_null' stops `re_search_2' from using the fastmap, so
< 	  bufp->can_be_null = 1;
<           fastmap[p[1]] = 1;
<           for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
< 	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
<               fastmap[j] = 1;
< 	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
<             fastmap[j] = 1;
< 	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
< 	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
<               fastmap[j] = 1;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	      fastmap[j] = 1;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	      fastmap[j] = 1;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
<             fastmap[j] = 1;
<             fastmap['\n'] = 0;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	      fastmap[j] = 1;
< 	  for (j = 0; j < (1 << BYTEWIDTH); j++)
< 	      fastmap[j] = 1;
< 	      && fail_stack.stack[fail_stack.avail - 1] == p)
<                 return -2;
<             bufp->can_be_null = 1;
<           p += 2;		
<               p -= 4;
<           p += 4;
< 	  p += 2;
< /* Like re_search_2, below, but only one string is specified, and
<   return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
<    virtual concatenation of STRING1 and STRING2, starting first at index
<    STARTPOS, then at STARTPOS + 1, and so on.
<    STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
<    In REGS, return the indices of the virtual concatenation of STRING1
<    and STRING2 that matched the entire BUFP->buffer and its contained
<    concatenation of STRING1 and STRING2.
<    found, -1 if no match, or -2 if error (such as failure
< re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
<      const char *string1, *string2;
<      int size1, size2;
<   int total_size = size1 + size2;
<     return -1;
<      the virtual concatenation of STRING1 and STRING2.  */
<   if (endpos < -1)
<     range = -1 - startpos;
< 	return -1;
< 	range = 1;
<     if (re_compile_fastmap (bufp) == -2)
<       return -2;
<               if (startpos < size1 && startpos + range >= size1)
<                 lim = range - (size1 - startpos);
< 	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
< 	      register char c = (size1 == 0 || startpos >= size1
<                                  ? string2[startpos - size1] 
<                                  : string1[startpos]);
< 	return -1;
<       val = re_match_2 (bufp, string1, size1, string2, size2,
<       if (val == -2)
< 	return -2;
<   return -1;
< } /* re_search_2 */
< /* Declarations and macros for re_match_2.  */
< #define MATCH_NULL_UNSET_VALUE 3
<     unsigned match_null_string_p : 2;
<     unsigned is_active : 1;
<     unsigned matched_something : 1;
<     unsigned ever_matched_something : 1;
< #define SET_REGS_MATCHED()						\
<   do									\
<     {									\
<       unsigned r;							\
<       for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
<         {								\
<           MATCHED_SOMETHING (reg_info[r])				\
<             = EVER_MATCHED_SOMETHING (reg_info[r])			\
<             = 1;							\
<         }								\
<     }									\
< /* This converts PTR, a pointer into one of the search strings `string1'
<    and `string2' into an offset from the beginning of that string.  */
< #define POINTER_TO_OFFSET(ptr)						\
<   (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
< #define REG_UNSET_VALUE ((char *) -1)
< /* Macros for dealing with the split strings in re_match_2.  */
< #define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
<    string2 if necessary.  */
< #define PREFETCH()							\
<   while (d == dend)						    	\
<     {									\
<       /* End of string2 => fail.  */					\
<       if (dend == end_match_2) 						\
<         goto fail;							\
<       /* End of string1 => advance to string2.  */ 			\
<       d = string2;						        \
<       dend = end_match_2;						\
<    of `string1' and `string2'.  If only one string, it's `string2'.  */
< #define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
< #define AT_STRINGS_END(d) ((d) == end2)	
<    two special cases to check for: if past the end of string1, look at
<    the first character in string2; and if before the beginning of
<    string2, look at the last character in string1.  */
< #define WORDCHAR_P(d)							\
<   (SYNTAX ((d) == end1 ? *string2					\
<            : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
< #define AT_WORD_BOUNDARY(d)						\
<   (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
<    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
< #define FREE_VARIABLES()						\
<   do {									\
<     FREE_VAR (fail_stack.stack);					\
<     FREE_VAR (regstart);						\
<     FREE_VAR (regend);							\
<     FREE_VAR (old_regstart);						\
<     FREE_VAR (old_regend);						\
<     FREE_VAR (best_regstart);						\
<     FREE_VAR (best_regend);						\
<     FREE_VAR (reg_info);						\
<     FREE_VAR (reg_dummy);						\
<     FREE_VAR (reg_info_dummy);						\
<    register values; since we have a limit of 255 registers (because
<    use numbers larger than 255.  They must differ by 1, because of
< #define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
< #define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
< /* re_match is like re_match_2 except it takes only a single string.  */
<   return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
< /* re_match_2 matches the compiled pattern in BUFP against the
<    the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
<    and SIZE2, respectively).  We start matching at POS, and stop
<    We return -1 if no match, -2 if an internal error (such as the
< re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
<      const char *string1, *string2;
<      int size1, size2;
<   unsigned char *p1;
<   const char *end1, *end2;
<   /* Pointers into string1 and string2, just past the last characters in
<   const char *end_match_1, *end_match_2;
<   unsigned num_regs = bufp->re_nsub + 1;
<   DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
<           return -2;
<   if (pos < 0 || pos > size1 + size2)
<       return -1;
<   /* Initialize subexpression text positions to -1 to mark ones that no
<   for (mcnt = 1; mcnt < num_regs; mcnt++)
<   /* We move `string1' into `string2' if the latter's empty -- but not if
<      `string1' is null.  */
<   if (size2 == 0 && string1 != NULL)
<       string2 = string1;
<       size2 = size1;
<       string1 = 0;
<       size1 = 0;
<   end1 = string1 + size1;
<   end2 = string2 + size2;
<   if (stop <= size1)
<       end_match_1 = string1 + stop;
<       end_match_2 = string2;
<       end_match_1 = end1;
<       end_match_2 = string2 + stop - size1;
<      equal `string2'.  */
<   if (size1 > 0 && pos <= size1)
<       d = string1 + pos;
<       dend = end_match_1;
<       d = string2 + pos - size1;
<       dend = end_match_2;
<   DEBUG_PRINT1 ("The compiled pattern is: ");
<   DEBUG_PRINT1 ("The string to match is: `");
<   DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
<   DEBUG_PRINT1 ("'\n");
<       DEBUG_PRINT2 ("\n0x%x: ", p);
<           DEBUG_PRINT1 ("end of pattern ... ");
<           if (d != end_match_2)
<               DEBUG_PRINT1 ("backtracking.\n");
<                       DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
<                       for (mcnt = 1; mcnt < num_regs; mcnt++)
<                      end_match_1' while the restored d is in string2.
<                   DEBUG_PRINT1 ("Restoring best registers.\n");
<                   dend = ((d >= string1 && d <= end1)
< 		           ? end_match_1 : end_match_2);
< 		  for (mcnt = 1; mcnt < num_regs; mcnt++)
<             } /* d != end_match_2 */
<           DEBUG_PRINT1 ("Accepting match.\n");
<                      extra element beyond `num_regs' for the `-1' marker
<                   regs->num_regs = MAX (RE_NREGS, num_regs + 1);
<                     return -2;
<                   if (regs->num_regs < num_regs + 1)
<                       regs->num_regs = num_regs + 1;
<                         return -2;
<                   regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
< 			          : d - string2 + size1);
< 	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
<                     regs->start[mcnt] = regs->end[mcnt] = -1;
<                  were in the pattern, set the extra elements to -1.  If
<                  -1 at the end.  */
<                 regs->start[mcnt] = regs->end[mcnt] = -1;
<           DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
<           DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
< 			    ? string1 
< 			    : string2 - size1);
<           DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING no_op.\n");
<           DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING anychar.\n");
<           if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
<               || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
<           DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
< 	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
<             DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
<                bit list is a full 32 bytes long.  */
< 		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
< 	    p += 1 + *p;
< 	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
< 	  p1 = p;		/* To send to group_match_null_string_p.  */
<               = group_match_null_string_p (&p1, pend, reg_info);
< 	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
< 	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
<           IS_ACTIVE (reg_info[*p]) = 1;
<           p += 2;
< 	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
< 	  DEBUG_PRINT2 ("      old_regend: %d\n", 
< 	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
<                  (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
<                  new highest active register is 1.  */
<               unsigned char r = *p - 1;
<                  registers 1 and 2 as a result of the *, but when we pop
<                  back to the second ), we are at the stop_memory 1.
<                || (re_opcode_t) p[-3] == start_memory)
< 	      && (p + 2) < pend)              
<               p1 = p + 2;
<               switch ((re_opcode_t) *p1++)
<                     EXTRACT_NUMBER_AND_INCR (mcnt, p1);
< 		      p1 += 2;
< 	      p1 += mcnt;
<               if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
<                   && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
<                      regstart[1], and, e.g., with `((a*)*(b*)*)*'
<                      against `aba' for regend[3].
<                      e.g., `((a*)(b*))*' against `aba' (register 3 would
<                       for (r = *p; r < *p + *(p + 1); r++)
< 		  p1++;
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                   PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
<           p += 2;
< 	/* \<digit> has been turned into a `duplicate' command which is
< 	    register const char *d2, *dend2;
< 	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
<             d2 = regstart[regno];
<             dend2 = ((FIRST_STRING_P (regstart[regno]) 
< 		     ? regend[regno] : end_match_1);
< 		while (d2 == dend2)
< 		    if (dend2 == end_match_2) break;
< 		    if (dend2 == regend[regno]) break;
<                     /* End of string1 => advance to string2. */
<                     d2 = string2;
<                     dend2 = regend[regno];
< 		if (d2 == dend2) break;
<                 if (mcnt > dend2 - d2)
< 		  mcnt = dend2 - d2;
<                     ? bcmp_translate (d, d2, mcnt, translate) 
<                     : bcmp (d, d2, mcnt))
< 		d += mcnt, d2 += mcnt;
<           DEBUG_PRINT1 ("EXECUTING begline.\n");
<           else if (d[-1] == '\n' && bufp->newline_anchor)
<           DEBUG_PRINT1 ("EXECUTING endline.\n");
<           else if ((d == end1 ? *string2 : *d) == '\n'
<           DEBUG_PRINT1 ("EXECUTING begbuf.\n");
<           DEBUG_PRINT1 ("EXECUTING endbuf.\n");
<         /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
<            matching `foo\nbar' against `.*\n'.  The .* matches the foo;
<            then the . fails against the \n.  But the next thing we want
<            to do is match the \n against the \n; if we restored the
<           DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
<           DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
<           PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
<           DEBUG_PRINT1 ("EXECUTING on_failure_jump");
<           DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
<              For example, in \(a*\)*\1, we need the preceding group,
<              and in \(\(a*\)b*\)\2, we need the inner group.  */
<           p1 = p;
<              the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
<           while (p1 < pend && (re_opcode_t) *p1 == no_op)
<             p1++;
<           if (p1 < pend && (re_opcode_t) *p1 == start_memory)
<               highest_active_reg = *(p1 + 1) + *(p1 + 2);
<                 lowest_active_reg = *(p1 + 1);
<           DEBUG_PRINT1 (":\n");
<           PUSH_FAILURE_POINT (p + mcnt, d, -2);
<           DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
< 	    register unsigned char *p2 = p;
< 	    while (p2 + 2 < pend
< 		   && ((re_opcode_t) *p2 == stop_memory
< 		       || (re_opcode_t) *p2 == start_memory))
< 	      p2 += 3;			/* Skip over args, too.  */
<             if (p2 == pend)
< 		/* Consider what happens when matching ":\(.*\)"
<   	        p[-3] = (unsigned char) pop_failure_jump;
<                 DEBUG_PRINT1
<                   ("  End of pattern: change to `pop_failure_jump'.\n");
<             else if ((re_opcode_t) *p2 == exactn
< 		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
<                   = *p2 == (unsigned char) endline ? '\n' : p2[2];
< 		p1 = p + mcnt;
<                 /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
<                 if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
<   		    p[-3] = (unsigned char) pop_failure_jump;
<                     DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
<                                   c, p1[5]);
< 		else if ((re_opcode_t) p1[3] == charset
< 			 || (re_opcode_t) p1[3] == charset_not)
< 		    int not = (re_opcode_t) p1[3] == charset_not;
< 		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
< 			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
<                     /* `not' is equal to 1 if c would match, which means
<   		        p[-3] = (unsigned char) pop_failure_jump;
<                         DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
< 	  p -= 2;		/* Point at relative address again.  */
< 	  if ((re_opcode_t) p[-1] != pop_failure_jump)
< 	      p[-1] = (unsigned char) jump;
<               DEBUG_PRINT1 ("  Match => jump.\n");
<             DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
<           DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
<           DEBUG_PRINT2 ("(to 0x%x).\n", p);
<           DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
<           DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
<           PUSH_FAILURE_POINT (0, 0, -2);
<           DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
<           PUSH_FAILURE_POINT (0, 0, -2);
<           EXTRACT_NUMBER (mcnt, p + 2);
<           DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
< 	       p += 2;
<                DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
<               DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
< 	      p[2] = (unsigned char) no_op;
<               p[3] = (unsigned char) no_op;
<           EXTRACT_NUMBER (mcnt, p + 2);
<           DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
<                STORE_NUMBER (p + 2, mcnt);
< 	    p += 4;		     
<             DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
<             p1 = p + mcnt;
<             DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
< 	    STORE_NUMBER (p1, mcnt);
<           DEBUG_PRINT1 ("EXECUTING wordbound.\n");
<           DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
<           DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
< 	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
<           DEBUG_PRINT1 ("EXECUTING wordend.\n");
< 	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
< #ifdef emacs19
<           DEBUG_PRINT1 ("EXECUTING before_dot.\n");
<           DEBUG_PRINT1 ("EXECUTING at_dot.\n");
<           DEBUG_PRINT1 ("EXECUTING after_dot.\n");
< #else /* not emacs19 */
<           DEBUG_PRINT1 ("EXECUTING at_dot.\n");
< 	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
< #endif /* not emacs19 */
<           DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
<           DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
<           DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
<           DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
<           DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
<           DEBUG_PRINT1 ("\nFAIL:\n");
<                   p1 = p + 1;
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                   p1 += mcnt;	
<                   if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
<                           && (re_opcode_t) *p1 == on_failure_jump))
<           if (d >= string1 && d <= end1)
< 	    dend = end_match_1;
<   return -1;         			/* Failure to match.  */
< } /* re_match_2 */
< /* Subroutine definitions for re_match_2.  */
<   unsigned char *p1 = *p + 2;
<   while (p1 < end)
<       switch ((re_opcode_t) *p1)
<           p1++;
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                  /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
<                  /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
<                  /exactn/1/c						
<                  So, we have to first go through the first (n-1)
<               /* Deal with the first (n-1) alternatives, which start
<               while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
<                   if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
<                   p1 += mcnt;	
<                   if ((re_opcode_t) *p1 != on_failure_jump)
< 		  p1++;
<                   EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<                   if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
<                       p1 -= 3;
<               EXTRACT_NUMBER (mcnt, p1 - 2);
<               if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
<               p1 += mcnt;	/* Get past the n-th alternative.  */
< 	  assert (p1[1] == **p);
<           *p = p1 + 2;
<           if (!common_op_match_null_string_p (&p1, end, reg_info))
<     } /* while p1 < end */
<   unsigned char *p1 = p;
<   while (p1 < end)
<       switch ((re_opcode_t) *p1)
<           p1++;
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<           p1 += mcnt;
<           if (!common_op_match_null_string_p (&p1, end, reg_info))
<     }  /* while p1 < end */
<   unsigned char *p1 = *p;
<   switch ((re_opcode_t) *p1++)
<       reg_no = *p1;
<       ret = group_match_null_string_p (&p1, end, reg_info);
<       EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<         p1 += mcnt;
<       p1 += 2;		
<       EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<           p1 -= 4;
<           EXTRACT_NUMBER_AND_INCR (mcnt, p1);
<           p1 += mcnt;
<       if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
<       p1 += 4;
<   *p = p1;
< /* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
< bcmp_translate (s1, s2, len, translate)
<      unsigned char *s1, *s2;
<   register unsigned char *p1 = s1, *p2 = s2;
<       if (translate[*p1++] != translate[*p2++]) return 1;
<      (and at least one extra will be -1).  */
<   bufp->newline_anchor = 1;
< /* Entry points compatible with 4.2 BSD regex library.  We don't define
<       re_comp_buf.buffer = (unsigned char *) malloc (200);
<       re_comp_buf.allocated = 200;
<       re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
<   re_comp_buf.newline_anchor = 1;
< /* POSIX.2 functions.  Don't define these for Emacs.  */
<       preg->newline_anchor = 1;
<   msg_size = strlen (msg) + 1; /* Includes the null.  */
<           strncpy (errbuf, msg, errbuf_size - 1);
<           errbuf[errbuf_size - 1] = 0;
<    Copyright (C) 1988 Free Software Foundation, Inc.
<    the Free Software Foundation; either version 2, or (at your option)
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
< /* Written June, 1988 by Mike Haertel
<    Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
< #define flag_stdlib 1
< #define flag_systypes 1
< #define flag_string 1
< #define flag_strings 1
< xmalloc_1(n)
< xrealloc_1(p, n)
< #define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
< #define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
< #define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
<   if ((index) >= (nalloc))			  \
<     {						  \
<       while ((index) >= (nalloc))		  \
< 	(nalloc) *= 2;				  \
<       REALLOC(p, t, nalloc);			  \
<   return c[b / INTBITS] & 1 << b % INTBITS;
<   c[b / INTBITS] |= 1 << b % INTBITS;
<   c[b / INTBITS] &= ~(1 << b % INTBITS);
< equal(s1, s2)
<      charclass s1;
<      charclass s2;
<     if (s1[i] != s2[i])
<   return 1;
<   syntax_bits_set = 1;
< #define FETCH(c, eoferr)   	      \
<   {			   	      \
<     if (! lexleft)	   	      \
<       if (eoferr != 0)	   	      \
< 	dfaerror(eoferr);  	      \
<       else		   	      \
< 	return END;	   	      \
<     (c) = (unsigned char) *lexptr++;  \
<     --lexleft;		   	      \
<   token c, c1, c2;
<   for (i = 0; i < 2; ++i)
< 	case '\\':
< 	    dfaerror("Unfinished \\ escape");
< 	  backslash = 1;
< 		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
< 		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
< 	          && lexleft > 0 && *lexptr == '\n'))
< 	case '1':
< 	case '2':
< 	case '3':
< 	case '4':
< 	case '5':
< 	case '6':
< 	case '7':
< 	case '8':
< 	case '9':
< 		  minrep = 10 * minrep + c - '0';
< 		maxrep = 10 * maxrep + c - '0';
< 	      if (c != '\\')
< 	  laststart = 1;
< 	case '\n':
< 	  laststart = 1;
< 	  laststart = 1;
< 	    clrbit('\n', ccl);
< 	    clrbit('\0', ccl);
< 	  for (c2 = 0; c2 < NOTCHAR; ++c2)
< 	    if (ISALNUM(c2))
< 	      setbit(c2, ccl);
< 	      invert = 1;
< 		for (c1 = 0; prednames[c1].name; ++c1)
< 		  if (looking_at(prednames[c1].name))
< 		      for (c2 = 0; c2 < NOTCHAR; ++c2)
< 			if ((*prednames[c1].pred)(c2))
< 			  setbit(c2, ccl);
< 		      lexptr += strlen(prednames[c1].name);
< 		      lexleft -= strlen(prednames[c1].name);
< 		      FETCH(c1, "Unbalanced [");
< 	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
< 	      FETCH(c1, "Unbalanced [");
< 	      if (c1 == '-')
< 		  FETCH(c2, "Unbalanced [");
< 		  if (c2 == ']')
< 			 which is left in c1, the lookahead character. */
< 		      c2 = c;
< 		      if (c2 == '\\'
< 			FETCH(c2, "Unbalanced [");
< 		      FETCH(c1, "Unbalanced [");
< 		c2 = c;
< 	      while (c <= c2)
< 	  while ((c = c1) != ']');
< 		clrbit('\n', ccl);
<   int ntoks1;
<   switch (dfa->tokens[tindex - 1])
<       return 1;
<       return 1 + nsubtoks(tindex - 1);
<       ntoks1 = nsubtoks(tindex - 1);
<       return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
< 	for (i = 1; i < minrep; ++i)
<   laststart = 1;
<   regexp(1);
<   position t1, t2;
<       t1 = p;
< 	  t2 = s->elems[i];
< 	  s->elems[i++] = t1;
< 	  t1 = t2;
< merge(s1, s2, m)
<      position_set *s1;
<      position_set *s2;
<   while (i < s1->nelem && j < s2->nelem)
<     if (s1->elems[i].index > s2->elems[j].index)
<       m->elems[m->nelem++] = s1->elems[i++];
<     else if (s1->elems[i].index < s2->elems[j].index)
<       m->elems[m->nelem++] = s2->elems[j++];
< 	m->elems[m->nelem] = s1->elems[i++];
< 	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
<   while (i < s1->nelem)
<     m->elems[m->nelem++] = s1->elems[i++];
<   while (j < s2->nelem)
<     m->elems[m->nelem++] = s2->elems[j++];
<       s->elems[i] = s->elems[i + 1];
<   newline = newline ? 1 : 0;
<   letter = letter ? 1 : 0;
< 	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
< 	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
< 	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
< 	d->states[i].backref = 1;
< 	visited[old.index] = 1;
< 	i = -1;
<    Note that at this point, we're pretending constructs like \< are real
<   fprintf(stderr, "dfaanalyze:\n");
<   putc('\n', stderr);
< 	*nullable++ = 1;
< 	tmp.nelem = nfirstpos[-1];
< 	for (j = 0; j < nlastpos[-1]; ++j)
< 				 nalloc[pos[j].index], merged.nelem - 1);
< 	  nullable[-1] = 1;
< 	tmp.nelem = nfirstpos[-1];
< 	pos = lastpos + nlastpos[-1];
< 	for (j = 0; j < nlastpos[-2]; ++j)
< 				 nalloc[pos[j].index], merged.nelem - 1);
< 	if (nullable[-2])
< 	  nfirstpos[-2] += nfirstpos[-1];
< 	  firstpos += nfirstpos[-1];
< 	if (nullable[-1])
< 	  nlastpos[-2] += nlastpos[-1];
< 	    pos = lastpos + nlastpos[-2];
< 	    for (j = nlastpos[-1] - 1; j >= 0; --j)
< 	    lastpos += nlastpos[-2];
< 	    nlastpos[-2] = nlastpos[-1];
< 	nullable[-2] = nullable[-1] && nullable[-2];
< 	nfirstpos[-2] += nfirstpos[-1];
< 	nlastpos[-2] += nlastpos[-1];
< 	nullable[-2] = nullable[-1] || nullable[-2];
< 	   constructs like \< are treated as nonempty strings here;
< 	*nfirstpos++ = *nlastpos++ = 1;
< 	nalloc[i] = 1;
<       putc('\n', stderr);
<       fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
<       for (j = nfirstpos[-1] - 1; j >= 0; --j)
<       fprintf(stderr, "\n lastpos:");
<       for (j = nlastpos[-1] - 1; j >= 0; --j)
<       putc('\n', stderr);
< 	for (j = d->follows[i].nelem - 1; j >= 0; --j)
< 	putc('\n', stderr);
<   for (i = 0; i < nfirstpos[-1]; ++i)
<       wants_newline = 1;
<   d->salloc = 1;
<       initialized = 1;
<       setbit('\n', newline);
< 					 d->states[s].newline, 1))
< 	    clrbit('\n', matches);
< 					d->states[s].letter, 1))
< 	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
< 	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
< 	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
< 	  grps[ngrps].nelem = 1;
< 	    wants_newline = 1;
< 	    wants_letter = 1;
< 	state_newline = state_index(d, &follows, 1, 0);
< 	state_letter = state_index(d, &follows, 0, 1);
< 	if (i == '\n')
<       trans[i] = -1;
<       if (tstbit('\n', labels[i]))
< 	    wants_newline = 1;
< 	    wants_letter = 1;
< 	state_newline = state_index(d, &follows, 1, 0);
< 	state_letter = state_index(d, &follows, 0, 1);
< 	  if (labels[i][j] & 1 << k)
< 	      if (c == '\n')
<      exist at once.  1024 is arbitrary.  The idea is that the frequently
<   if (d->trcount >= 1024)
<   if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
<     d->success[s] |= 4;
<   if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
<     d->success[s] |= 2;
<     d->success[s] |= 1;
< 	  d->tralloc *= 2;
< 	REALLOC(d->realtrans, int *, d->tralloc + 1);
< 	d->trans = d->realtrans + 1;
<   d->newlines[s] = trans['\n'];
<   trans['\n'] = -1;
<   d->tralloc = 1;
<   CALLOC(d->realtrans, int *, d->tralloc + 1);
<   d->trans = d->realtrans + 1;
<    where we're supposed to store a 1 if backreferencing happened and the
<   register s, s1, tmp;		/* Current state. */
<       sbit_init = 1;
< 	if (i == '\n')
< 	  sbit[i] = 4;
< 	  sbit[i] = 2;
< 	  sbit[i] = 1;
<   s = s1 = 0;
<   *end = '\n';
< 	    s1 = t[*p++];
< 	    if (! (t = trans[s1]))
<       goto last_was_s1;
<       tmp = s, s = s1, s1 = tmp;
<     last_was_s1:
< 		  *backref = 1;
< 	  s1 = s;
<       if (count && (char *) p <= end && p[-1] == '\n')
<       if (p[-1] == '\n' && newline)
< 	  s = d->newlines[s1];
<   d->calloc = 1;
<   d->talloc = 1;
<       case_fold = 1;
<     result = (char *) malloc(newsize + 1);
<     result = (char *) realloc((void *) old, oldsize + newsize + 1);
<   for (cp = lookin; *cp != '\0'; ++cp)
<   new[len] = '\0';
<   cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
<   cpp[i + 1] = NULL;
<   for (lcp = left; *lcp != '\0'; ++lcp)
< 	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
< 	  rcp = index(rcp + 1, *lcp);
<   mp->left[0] = mp->right[0] = mp->is[0] = '\0';
<   musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
<       mp[i].left = malloc(2);
<       mp[i].right = malloc(2);
<       mp[i].is = malloc(2);
<       mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
<   fprintf(stderr, "dfamust:\n");
<   putc('\n', stderr);
< 	  if (mp < &musts[2])
< 	      lmp->is[0] = '\0';
< 	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
< 	    lmp->left[i] = '\0';
< 	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
< 	    lmp->right[j] = '\0';
< 	  mp->is[0] = '\0';
< 	  if (mp != &musts[1])
< 	    exact = 1;
< 	  if (mp < &musts[2])
< 	    if (lmp->right[0] != '\0' &&
< 		rmp->left[0] != '\0')
< 	    if (lmp->is[0] != '\0')
< 	    if (rmp->is[0] == '\0')
< 	      lmp->right[0] = '\0';
< 	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
< 	      lmp->is[0] = '\0';
< 	  else if (t == '\0')
< 	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
< 	      mp->in = enlist(mp->in, mp->is, 1);
<       fprintf(stderr, "\n  in:");
< 	fprintf(stderr, " \"%s\"", mp->in[i]);
<       fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
<       fprintf(stderr, "  left: \"%s\"\n", mp->left);
<       fprintf(stderr, "  right: \"%s\"\n", mp->right);
<       dm->must = malloc(strlen(result) + 1);
<    Copyright 1989 Free Software Foundation
< 		  Written August 1989 by Mike Haertel.
<    the Free Software Foundation; either version 1, or (at your option)
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<    IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
<    String Matching:  An Aid to Bibliographic Search," CACM June 1975,
<    Vol. 18, No. 6, which describes the failure function used below. */
< #define flag_limits 1
< #define flag_stdlib 1
< #define INT_MAX 2147483647
< #define UCHAR_MAX 255
< #define flag_systypes 1
< #define flag_string 1
< #define flag_memory 1
< #define NCHAR (UCHAR_MAX + 1)
<   int mind2;			/* Used in Boyer-Moore search for one string. */
<   kwset->maxd = -1;
<   struct tree *links[12];
<   enum { L, R } dirs[12];
<       depth = 1;
< 	  link->trie->depth = trie->depth + 1;
< 		case (char) -2:
< 		  switch (dirs[depth + 1])
< 		      l->balance = t->balance != 1 ? 0 : -1;
< 		      r->balance = t->balance != (char) -1 ? 0 : 1;
< 		case 2:
< 		  switch (dirs[depth + 1])
< 		      l->balance = t->balance != 1 ? 0 : -1;
< 		      r->balance = t->balance != (char) -1 ? 0 : 1;
< 	      if (dirs[depth - 1] == L)
< 		links[depth - 1]->llink = t;
< 		links[depth - 1]->rlink = t;
<     trie->accepting = 1 + 2 * kwset->words;
<     return 1;
<   if (kwset->mind < 256)
<       delta[i] = 255;
<   if (kwset->words == 1 && kwset->trans == 0)
<       for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
< 	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
<       kwset->mind2 = kwset->mind;
<       /* Find the minimal delta2 shift that we might make after
<       for (i = 0; i < kwset->mind - 1; ++i)
< 	if (kwset->target[i] == kwset->target[kwset->mind - 1])
< 	  kwset->mind2 = kwset->mind - (i + 1);
<   register unsigned char *d1;
<   register int d, gc, i, len, md2;
<   if (len == 1)
<   d1 = kwset->delta;
<   gc = U(sp[-2]);
<   md2 = kwset->mind2;
<   /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
<   if (size > 12 * len)
<     /* 11 is not a bug, the initial offset happens only once. */
<     for (ep = text + size - 11 * len;;)
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	    d = d1[U(tp[-1])], tp += d;
< 	if (U(tp[-2]) == gc)
< 	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
< 	tp += md2;
<   d = d1[U(tp[-1])];
<       d = d1[U((tp += d)[-1])];
<       if (tp[-2] == gc)
< 	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
<       d = md2;
<   if (len >= 4 * kwset->mind)
<     qlim = lim - 4 * kwset->mind;
< 	  end += d - 1;
< 	d = delta[c = (end += d)[-1]];
<       beg = end - 1;
<   d = 1;
<       if ((d = delta[c = (end += d)[-1]]) != 0)
<       beg = end - 1;
< 	  d = 1;
< 	d = 1;
<       kwsmatch->index = accept->accepting / 2;
<   if (kwset->words == 1 && kwset->trans == 0)
<    Copyright (C) 1988, 1993 Free Software Foundation, Inc.
< Free Software Foundation; either version 2, or (at your option) any
< Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
< #define DEFAULT_ALIGNMENT  \
< #define CALL_CHUNKFUN(h, size) \
<   (((h) -> use_extra_arg) \
<    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
< #define CALL_FREEFUN(h, old_chunk) \
<   do { \
<     if ((h) -> use_extra_arg) \
<       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
<     else \
<       (*(h)->freefun) ((old_chunk)); \
<     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
<       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
< 	 and we used a larger request, a whole extra 4096 bytes would be
<       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
< 		    + 4 + DEFAULT_ROUNDING - 1)
< 		   & ~(DEFAULT_ROUNDING - 1));
<       size = 4096 - extra;
<   h->alignment_mask = alignment - 1;
< _obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
<     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
<       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
< 	 and we used a larger request, a whole extra 4096 bytes would be
<       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
< 		    + 4 + DEFAULT_ROUNDING - 1)
< 		   & ~(DEFAULT_ROUNDING - 1));
<       size = 4096 - extra;
<   h->alignment_mask = alignment - 1;
<   h->use_extra_arg = 1;
<   new_size = (obj_size + length) + (obj_size >> 3) + 100;
<   if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
<       for (i = obj_size / sizeof (COPYING_UNIT) - 1;
<       h->maybe_empty_object = 1;
<       h->maybe_empty_object = 1;
< void (obstack_1grow) (obstack, character)
<   obstack_1grow (obstack, character);
< void (obstack_1grow_fast) (obstack, character)
<   obstack_1grow_fast (obstack, character);
<    Copyright (C) 1992 Free Software Foundation, Inc.
<    the Free Software Foundation; either version 2, or (at your option)
<    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<    Written August 1992 by Mike Haertel. */
< #define flag_limits 1
< #define flag_stdlib 1
< #define UCHAR_MAX 255
< #define flag_systypes 1
< #define flag_string 1
< #define flag_memory 1
< #define NCHAR (UCHAR_MAX + 1)
< static struct dfa dfa_1;
<   if (dfa_1.musts)
<       for (dm = dfa_1.musts; dm; dm = dm->next)
<       for (dm = dfa_1.musts; dm; dm = dm->next)
<   dfainit(&dfa_1);
<       char *n = malloc(size + 50);
< 	strcpy(n, "^\\(");
< 	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
< 	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
< 	strcpy(n + i, "\\)$");
<       dfacomp(n, i, &dfa_1, 1);
<     dfacomp(pattern, size, &dfa_1, 1);
<   dfainit(&dfa_1);
<       char *n = malloc(size + 50);
< 	strcpy(n, "(^|[^0-9A-Za-z_])(");
< 	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
<       dfacomp(n, i, &dfa_1, 1);
<     dfacomp(pattern, size, &dfa_1, 1);
<   for (beg = end = buf; end < buflim; beg = end + 1)
< 	  end = memchr(beg, '\n', buflim - beg);
< 	  while (beg > buf && beg[-1] != '\n')
< 	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
< 	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
< 	  end = memchr(beg, '\n', buflim - beg);
< 	  while (beg > buf && beg[-1] != '\n')
< 		if ((start == 0 || !WCHAR(beg[start - 1]))
< 		    regex.not_eol = 1;
<   *endp = end < buflim ? end + 1 : end;
<       for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
< 	  if (beg > buf && beg[-1] != '\n')
< 	  if (beg + len < buf + size && beg[len] != '\n')
< 	    if (try > buf && WCHAR((unsigned char) try[-1]))
<   if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
<   while (beg > buf && beg[-1] != '\n')
< 3if gout
< 3eif agout end = buf + size;
< 3if goutfvf
< 3eif agoutvf end = buf + size;
